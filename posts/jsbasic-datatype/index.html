<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaScript 基础 - 数据类型、运算符、类型转换 | Donna'Log</title><meta name="author" content="Donna Tang"><meta name="copyright" content="Donna Tang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据类型原始（Primitive）类型原始（Primitive）值一般叫做栈数据（一旦开了个房间、不可能在这个房间里对其进行修改） 在 JS 中，存在着以下几种原始值，分别是：  number（typeof 1 &#x3D;&#x3D;&#x3D; &quot;number&quot;） string（typeof &#39;&#39; &#x3D;&#x3D;&#x3D; &quot;string&quot;） boolean（typeof true &#x3D;">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 基础 - 数据类型、运算符、类型转换">
<meta property="og:url" content="https://donnapersonal.github.io/cn/posts/jsbasic-datatype/">
<meta property="og:site_name" content="Donna&#39;Log">
<meta property="og:description" content="数据类型原始（Primitive）类型原始（Primitive）值一般叫做栈数据（一旦开了个房间、不可能在这个房间里对其进行修改） 在 JS 中，存在着以下几种原始值，分别是：  number（typeof 1 &#x3D;&#x3D;&#x3D; &quot;number&quot;） string（typeof &#39;&#39; &#x3D;&#x3D;&#x3D; &quot;string&quot;） boolean（typeof true &#x3D;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.7i0rgcc8cp.webp">
<meta property="article:published_time" content="2021-05-16T19:49:09.000Z">
<meta property="article:modified_time" content="2025-10-02T21:59:25.306Z">
<meta property="article:author" content="Donna Tang">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.7i0rgcc8cp.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JavaScript 基础 - 数据类型、运算符、类型转换",
  "url": "https://donnapersonal.github.io/cn/posts/jsbasic-datatype/",
  "image": "https://github.com/donnapersonal/picx-images-hosting/raw/master/image.7i0rgcc8cp.webp",
  "datePublished": "2021-05-16T19:49:09.000Z",
  "dateModified": "2025-10-02T21:59:25.306Z",
  "author": [
    {
      "@type": "Person",
      "name": "Donna Tang",
      "url": "https://donnapersonal.github.io/cn"
    }
  ]
}</script><link rel="shortcut icon" href="/cn/img/favicon.png"><link rel="canonical" href="https://donnapersonal.github.io/cn/posts/jsbasic-datatype/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/cn/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/cn/',
  algolia: undefined,
  localSearch: {"path":"/cn/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Donna Tang","link":"链接: ","source":"来源: Donna'Log","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript 基础 - 数据类型、运算符、类型转换',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://oss.012700.xyz/butterfly/2024/10/index.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/cn/img/avatar.JPG" onerror="this.onerror=null;this.src='/cn/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/cn/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/cn/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/cn/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/cn/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/cn/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/cn/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/cn/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://donnapersonal.github.io/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/cn/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/cn/"><span class="site-name">Donna'Log</span></a><a class="nav-page-title" href="/cn/"><span class="site-name">JavaScript 基础 - 数据类型、运算符、类型转换</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/cn/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/cn/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/cn/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/cn/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://donnapersonal.github.io/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/cn/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JavaScript 基础 - 数据类型、运算符、类型转换<a class="post-edit-link" href="null_posts/jsbasic-datatype.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-16T19:49:09.000Z" title="发表于 2021-05-16 15:49:09">2021-05-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-02T21:59:25.306Z" title="更新于 2025-10-02 17:59:25">2025-10-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/cn/categories/Frontend/">Frontend</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/cn/categories/Frontend/JS/">JS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><h2 id="原始（Primitive）类型"><a href="#原始（Primitive）类型" class="headerlink" title="原始（Primitive）类型"></a>原始（Primitive）类型</h2><p>原始（<code>Primitive</code>）值一般叫做<code>栈数据</code>（一旦开了个房间、不可能在这个房间里对其进行修改）</p>
<p>在 <code>JS</code> 中，存在着以下几种原始值，分别是：</p>
<ul>
<li><code>number</code>（<code>typeof 1 === &quot;number&quot;</code>）</li>
<li><code>string</code>（<code>typeof &#39;&#39; === &quot;string&quot;</code>）</li>
<li><code>boolean</code>（<code>typeof true === &quot;boolean&quot;</code>）</li>
<li><code>null</code>（<code>typeof null === &quot;object&quot;</code>）</li>
<li><code>undefined</code>（<code>typeof undefined === &quot;undefined&quot;</code>）</li>
<li><code>symbol</code>（<code>typeof Symbol() === &quot;symbol&quot;</code>）</li>
<li><code>bigInt</code>（<code>typeof 10n === &quot;bigint&quot;</code>）(没有正式发布但即将被加入标准的原始类型)</li>
</ul>
<p>原始类型存储的都是<code>值</code>，是没有函数可以调用的，如 <code>undefined.toString()</code> 会报错，一般看到的 <code>&#39;1&#39;.toString()</code> 可以调用成功是因为实际上它已经被强制转换成了 <code>String</code> 类型即对象类型，所以才可以调用 <code>toString</code> 函数</p>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/toString.8ojtezis3g.webp" alt="undefined.toString()"></p>
<h3 id="undefined-和-null-的区别"><a href="#undefined-和-null-的区别" class="headerlink" title="undefined 和 null 的区别"></a>undefined 和 null 的区别</h3><p>相同点：用 <code>if</code> 判断时两者都会被转换成 <code>false</code></p>
<p>不同点：</p>
<ul>
<li><p><code>number</code> 转换的值不同</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Number</span>(<span class="literal">null</span>); <span class="comment">// 0</span></span><br><span class="line"><span class="title class_">Number</span>(<span class="literal">undefined</span>); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>null</code> 有值，但这个值是空值，表示为空，代表此处不应该有值的存在。一个对象可以是 <code>null</code> 代表是个空对象，<code>null</code> 一般用作占位</p>
</li>
<li><p><code>undefined</code> 是未定义，表示不存在，完全没有值的意思。<code>JavaScript</code> 是一⻔动态类型语言，成员除了表示存在的空值外还有可能根本就不存在(因为存不存在只在运行期才知道)，这就是 <code>undefined</code> 的意义所在</p>
</li>
</ul>
<h3 id="typeof-null-的结果为什么是-object"><a href="#typeof-null-的结果为什么是-object" class="headerlink" title="typeof null 的结果为什么是 object"></a>typeof null 的结果为什么是 object</h3><p><code>typeof null</code> 会输出 <code>object</code>，这是 <code>JS</code> 存在的一个悠久 <code>Bug</code>，在 <code>JS</code> 的最初版本中使用的是 <code>32</code> 位系统，为了性能考虑使用<code>低位</code>存储变量的类型信息，<code>000</code> 开头代表是对象，然而 <code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code></p>
<h3 id="为什么-0-1-0-2-0-3？"><a href="#为什么-0-1-0-2-0-3？" class="headerlink" title="为什么 0.1 + 0.2 !&#x3D;&#x3D; 0.3？"></a>为什么 0.1 + 0.2 !&#x3D;&#x3D; 0.3？</h3><p>分析详见：<a href="https://donnapersonal.github.io/2021/0.1+0.2/">为什么 0.1 + 0.2 !&#x3D;&#x3D; 0.3</a></p>
<h3 id="如何判断一个数据是-NaN？"><a href="#如何判断一个数据是-NaN？" class="headerlink" title="如何判断一个数据是 NaN？"></a>如何判断一个数据是 NaN？</h3><p><code>NaN</code> 是非数字，但使用 <code>typeof</code> 检测是 <code>number</code> 类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">typeof</span>(<span class="title class_">NaN</span>); <span class="comment">// &#x27;number&#x27;</span></span><br></pre></td></tr></table></figure>

<p>判断一个数据是 <code>NaN</code> 的方法如下：</p>
<ul>
<li>利用 <code>NaN</code> 的定义：用 <code>typeof</code> 检测是否是 <code>number</code> 类型且判断是否满足 <code>isNaN</code></li>
<li>利用 <code>NaN</code> 是唯一一个不等于任何自身的特点 <code>n !== n</code></li>
<li>利用 <code>ES6</code> 中提供的 <code>Object.is()</code> 方法，判断两个值是否相等 <code>n == NaN</code></li>
</ul>
<h3 id="为什么会有-BigInt-的提案？"><a href="#为什么会有-BigInt-的提案？" class="headerlink" title="为什么会有 BigInt 的提案？"></a>为什么会有 BigInt 的提案？</h3><p><code>JavaScript</code> 中 <code>Number.MAX_SAFE_INTEGER</code> 表示最大安全数字，计算结果是 <code>9007199254740991</code>，即在这个数范围内不会出现精度丢失(小数除外)</p>
<p>但一旦超过这个范围，<code>JS</code> 就会出现计算不准确的情况，这在大数计算时不得不依靠一些第三方库进行解决，因此官方提出了 <code>BigInt</code> 来解决此问题</p>
<p><code>BigInt</code> 类型可以用任意精度表示整数，使用 <code>BigInt</code> 可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制，<code>BigInt</code> 是通过在整数末尾附加 <code>n</code> 或调用构造函数来创建的</p>
<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>一般叫做<code>堆数据</code>，包括：</p>
<ul>
<li>对象(<code>Object</code>)（<code>typeof &#123;&#125; === &quot;object&quot;</code>）</li>
<li>数组(<code>Array</code>)（<code>typeof [] === &quot;object&quot;</code>）</li>
<li>函数(<code>Function</code>)（<code>typeof function()&#123;&#125; === &quot;function&quot;</code>）</li>
</ul>
<p><strong>引用类型与原始类型的区别：</strong></p>
<ul>
<li><p>因为原始值是存放在栈里的，而引用值是存放在堆里的，原始值不可以被改变，引用值可以被改变</p>
</li>
<li><p>原始值的赋值是把值的内容赋值一份给另一个变量，栈内存一旦被赋值了就不可以改变，即使给 <code>num</code> 重新赋值为 <code>234</code>，也是在栈里重新开辟了一块空间赋值 <code>234</code>，然后把 <code>num</code> 指向了这个空间，前面那个存放 <code>123</code> 的空间还存在</p>
</li>
<li><p>但引用值却不是这样：<code>引用值的变量名存在栈里，但值却是存在堆里，栈里的变量名只是个指针并指向了一个堆空间</code>，这个堆空间存的是一开始赋的值，当 <code>arr1 = arr</code> 时，其实是把 <code>arr1</code> 指向了和 <code>arr</code> 指向的同一个堆空间，这样当改变 <code>arr</code> 的内容时，就改变了这个堆空间的内容，自然同样指向这个堆空间的 <code>arr1</code> 的值也随着改变</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// num的改变对num1完全没有影响</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>, num1 = num;</span><br><span class="line">num = <span class="number">234</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num) <span class="comment">// 234</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num1) <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 只是改变了 arr 的值，但 arr1 也跟着改变了</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], arr1 = arr;</span><br><span class="line">arr.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr) <span class="comment">// [1,2,3,4]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr1) <span class="comment">// [1,2,3,4]</span></span><br></pre></td></tr></table></figure>

<p>再来看个函数参数是对象的情况</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">person</span>) &#123;</span><br><span class="line">  person.<span class="property">age</span> = <span class="number">26</span></span><br><span class="line">  person = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;yyy&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;yck&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">25</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title function_">test</span>(p1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1) <span class="comment">// &#123;name: &quot;yck&quot;, age: 26&#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2) <span class="comment">// &#123;name: &quot;yyy&quot;, age: 30&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>上面代码中，首先函数传参是传递对象指针的副本</li>
<li>到函数内部修改参数的属性这步，当前 <code>p1</code> 的值也被修改了</li>
<li>但当重新为 <code>person</code> 分配了一个对象时就出现了分歧，请看下图，所以最后 <code>person</code> 拥有了一个新的地址（指针），即和 <code>p1</code> 没有任何关系，导致了最终两个变量的值是不相同的</li>
</ul>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/reference_value.7i0i6dtvi2.webp" alt="函数参数是对象的情况"></p>
</li>
<li><p>无法直接操纵堆中的数据，即无法直接操纵对象，但可通过栈中对对象的引用来操作对象，就像通过遥控机操作电视机一样，区别在于这个电视机本身并没有控制按钮</p>
</li>
</ul>
<blockquote>
<p>为什么要区分堆栈？</p>
<p>变量的主要形式：</p>
<ul>
<li>一种内容短小（如 <code>int</code> 整数），需频繁访问，但生命周期很短，通常只在一个方法内存活</li>
<li>一种内容可能很多（如很长一段字符串），可能不需太频繁的访问，生命周期较长，通常很多方法中可能都要用到</li>
</ul>
<p><code>堆区</code>就是各种慢：申请内存慢、访问慢、修改慢、释放慢、整理慢（或说 <code>GC</code> 垃圾回收机制），但优点不言而喻：访问随机灵活、空间超大、在不超可用内存的情况下要多大就给多大</p>
<p><code>栈区</code>速度超快，但缺点如生命周期短，一般只能在一个方法内存活；需事先知道需要多大的栈（事实上绝大多数语言栈区要分配的大小在编译期就确定了，如 <code>Java</code>），通常最大栈区可用内存都很小，不可能往栈区堆很多数据</p>
</blockquote>
<p>不将原始类型放在堆是因为是为了不影响栈的效率，且通过引用到堆中查找实际对象是要花费时间的，而这个综合成本远大于直接从栈中取得实际值的成本，所以原始类型值直接存放在栈中</p>
<blockquote>
<p><code>堆</code>和<code>栈</code>分别是不同的数据结构：</p>
<ul>
<li>栈是线性表的一种</li>
<li>堆则是树形结构</li>
</ul>
</blockquote>
<h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><h2 id="算术运算符（算术运算符的优先级是从左到右的）"><a href="#算术运算符（算术运算符的优先级是从左到右的）" class="headerlink" title="算术运算符（算术运算符的优先级是从左到右的）"></a>算术运算符（算术运算符的优先级是从左到右的）</h2><ul>
<li><code>+</code>：数学上的相加功能、拼接字符串（字符串和任何数据相加都会变成字符串）</li>
<li><code>–/*///%</code>：分别对应数学上的相减、相乘、相除、取余功能</li>
<li><code>=</code>：赋值运算符，优先级最低</li>
<li><code>()</code>：和数学上一样，加括号的部分优先级最高</li>
<li><code>++</code>：自加 <code>1</code> 运算，当写在变量前时是先自加 <code>1</code> 再执行运算，写在变量后时是先运算再自加 <code>1</code></li>
<li><code>--</code>：用法和 <code>++</code> 一样，不过是减法操作</li>
<li><code>+=</code>：让变量自加多少</li>
<li>相同的还有 <code>-=</code>、<code>/=</code>、<code>*-</code>、<code>%=</code> 等</li>
</ul>
<h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>比较运算符有 <code>&gt;</code>、<code>&lt;</code>、<code>&gt;=</code>、<code>&lt;=</code>、<code>!=</code>、<code>== 不严格等于</code>、<code>=== 严格等于</code></p>
<p><code>==</code> 和 <code>===</code> 的区别：<strong>当比较两个数据时，是否先转化成同一个类型的数据后再进行比较</strong></p>
<ul>
<li><code>==</code> 即这两个数据进行了类型转换后值相等则相等</li>
<li><code>===</code> 则是两个数据不进行数据转化也相等时则相等</li>
</ul>
<blockquote>
<p>注：<code>NaN</code> 不等于任何数据包括它本身，<code>null</code> 和 <code>undefined</code> 就等于它本身</p>
</blockquote>
<h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符主要是 <code>与(&amp;&amp;)</code> 和 <code>或（||)</code></p>
<ul>
<li><p><code>&amp;&amp;</code>：只有是 <code>true</code> 时才会继续往后执行，一旦第一个表达式错了，后面的第二个表达式根本不执行；若表达式的返回结果都是 <code>true</code> 则这里 <code>&amp;&amp;</code> 的返回结果是最后一个正确的表达式的结果</p>
</li>
<li><p><code>||</code>：只要有一个表达式是 <code>true</code> 则结束，后面的就不走了且返回的结果是这个正确的表达式的结果，若都是 <code>false</code> 则返回结果就是 <code>false</code></p>
</li>
</ul>
<p>一般来说，<code>&amp;&amp;</code> 有当做短路语句的作用，因为运算符的运算特点，只有第一个条件成立时才会运行第二个表达式，所以可以把简单的 <code>if</code> 语句用 <code>&amp;&amp;</code> 来表现出来</p>
<p>一般来说，<code>||</code> 有当做赋初值的作用，有时希望函数参数有一个初始值，在不使用 <code>ES6</code> 的语法的情况下，最好的做法就是利用 <code>||</code> 语句</p>
<p>注意：这里有一个缺点，当传的参数是一个布尔值且传的是 <code>false</code>，则 <code>||</code> 语句的特点就会忽略掉所传的这个参数值而去赋成默认的初始值，所以为了解决这个弊端，就需利用 <code>ES6</code> 的一些知识</p>
<blockquote>
<p>默认为 <code>false</code> 的值：<code>undefined</code>、<code>null</code>、<code>&quot; &quot;</code>、<code>0</code>、<code>-0</code>、<code>false</code>、<code>NaN</code></p>
</blockquote>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h2><p><code>typeof</code> 能返回的类型一共有：<code>numner</code>、<code>string</code>、<code>boolean</code>、<code>undefined</code>、<code>symbol</code>、<code>bigInt</code>、<code>object</code>、<code>function</code></p>
<ul>
<li><p><code>数组</code>和 <code>null</code> 的都返回 <code>&quot;object&quot;</code></p>
</li>
<li><p><code>NaN</code> 属于 <code>number</code> 类型：虽然是非数，但非数也是数字的一种</p>
</li>
<li><p><code>Number(mix)</code>：该方法可以把其他类型的数据转换成数字类型的数据</p>
</li>
<li><p><code>parseInt(string, radix)</code>：该方法是将字符串转换成整型数字类型的</p>
<ul>
<li>第二个参数 <code>radix</code> 是可选择的参数</li>
<li>当 <code>string</code> 里既包括数字又包括其他字符时会从左到右只会转换数字部分，遇到其他非数字的字符就停止，即使后面还有数字也不会继续转换</li>
<li>当 <code>radix</code> 不为空时，该函数可用来作为进制转换，<code>radix</code> 作用则是把第一个参数的数字当成几进制的数字来转换成十进制（<code>radix</code> 参数的范围是 <code>2 ~ 36</code>）</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String(100000000000000000000000) -&gt; &quot;1e+23&quot;</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">100000000000000000000000</span>);  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>parseFloat(string, radix)</code>：这个方法和 <code>parseInt</code> 类似，将字符串转换成浮点类型的数字，同样是碰到第一个非数字型字符停止</p>
<ul>
<li>由于浮点型数据有小数点，它会识别第一个小数点以及后面的数字，但第二个小数点则无法识别</li>
<li>一旦数字变得足够大，其字符串表示将以指数形式呈现。如下，此时得到的是 <code>1</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="number">100000000000000000000000</span>); <span class="comment">// 1e+23</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toString(radix)</code>：它是对象上的方法，任何数据类型都可使用，转换成字符串类型</p>
<ul>
<li>同样 <code>radix</code> 基底是可选参数，当为空时仅仅代表将数据转化成字符串</li>
<li>当写了 <code>radix</code> 基底时则代表要将这个数字转化成几进制的数字型字符串</li>
</ul>
<blockquote>
<p>注意：<code>undefined</code> 和 <code>null</code> 没有 <code>toString</code> 方法</p>
</blockquote>
</li>
<li><p><code>String(mix)</code>：把任何类型转换成字符串类型</p>
</li>
<li><p><code>Boolean(mix)</code>：把任何类型转换成布尔类型</p>
</li>
</ul>
<h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p><strong>isNaN()</strong></p>
<p>这个方法可以检测数据是不是非数类型，这中间隐含了一个隐式转换，先将传的参数调用 <code>Number</code> 方法，再看结果是不是 <code>NaN</code>，该方法可以检测 <code>NaN</code> 本身</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="title class_">NaN</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">&#x27;abc&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="number">123</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>算术运算符</strong></p>
<p><code>++ n</code>：先将数据调一遍 <code>Number</code> 后，再自加 <code>n</code></p>
<p><code>n ++</code>：虽然是执行完后才自加 <code>n</code>，但执行前就调用 <code>Number</code> 进行类型转换</p>
<p>同样一目运算符也可以进行类型转换：<code>+</code>、<code>-</code>、<code>*、</code>&#x2F;&#96; 在执行前都会先转换成数字类型再进行运算</p>
<p><strong>逻辑运算符</strong></p>
<p>逻辑运算符也会隐式调用类型转换</p>
<ul>
<li><code>&amp;&amp;</code> 和 <code>||</code> 都是先把表达式调用 <code>Boolean</code> 换成布尔值再进行判断，不过返回的结果还是本身表达式的结果</li>
<li><code>!</code> 取反操作符返回的结果也是调用 <code>Boolean</code> 方法后的结果</li>
</ul>
<blockquote>
<p>转 <code>Boolean</code>：在条件判断时除了 <code>undefined</code>，<code>null</code>，<code>false</code>，<code>NaN</code>，<code>&#39;&#39;</code>，<code>0</code>，<code>-0</code>，其他所有值都转为 <code>true</code>，包括<code>所有对象</code></p>
</blockquote>
<h2 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h2><table>
<thead>
<tr>
<th>原始值</th>
<th>转换为数值</th>
<th>转换为字符串</th>
<th>转换为布尔值</th>
</tr>
</thead>
<tbody><tr>
<td>number</td>
<td>&#x2F;</td>
<td>0 -&gt; &quot;0&quot;，5 -&gt; &quot;5&quot;</td>
<td>除了 0、-0、NaN 外均为 true</td>
</tr>
<tr>
<td>string</td>
<td>&quot;&quot; -&gt; 0，&quot;1&quot; -&gt; 1，&quot;a&quot; -&gt; NaN</td>
<td>&#x2F;</td>
<td>除了空字符串均为 true</td>
</tr>
<tr>
<td>undefined</td>
<td>NaN</td>
<td>&quot;undefined&quot;</td>
<td>false</td>
</tr>
<tr>
<td>null</td>
<td>0</td>
<td>&quot;null&quot;</td>
<td>false</td>
</tr>
<tr>
<td>[]</td>
<td>0</td>
<td>&quot;&quot;</td>
<td>true</td>
</tr>
<tr>
<td>[10,20]</td>
<td>NaN</td>
<td>&quot;10,20&quot;</td>
<td>true</td>
</tr>
<tr>
<td>{}</td>
<td>NaN</td>
<td>&quot;[object, Object]&quot;</td>
<td>true</td>
</tr>
<tr>
<td>{a: 1}</td>
<td>NaN</td>
<td>&quot;[object, Object]&quot;</td>
<td>true</td>
</tr>
<tr>
<td>function(){}</td>
<td>NaN</td>
<td>&quot;function(){}&quot;</td>
<td>true</td>
</tr>
<tr>
<td>true</td>
<td>1</td>
<td>&quot;true&quot;</td>
<td>true</td>
</tr>
<tr>
<td>false</td>
<td>0</td>
<td>&quot;false&quot;</td>
<td>false</td>
</tr>
<tr>
<td>Symbol</td>
<td>NaN</td>
<td>&quot;function Symbol(){[native code]}&quot;</td>
<td>true</td>
</tr>
<tr>
<td>Symbol()</td>
<td>抛错</td>
<td>&quot;Symbol()&quot;</td>
<td>true</td>
</tr>
</tbody></table>
<h2 id="引用类型转换为原始类型"><a href="#引用类型转换为原始类型" class="headerlink" title="引用类型转换为原始类型"></a>引用类型转换为原始类型</h2><h3 id="ToPrimitive"><a href="#ToPrimitive" class="headerlink" title="[[ToPrimitive]]"></a>[[ToPrimitive]]</h3><p>引用类型在转换类型时会调用内置的 <code>[[ToPrimitive]]</code> 函数</p>
<p><code>ToPrimitive(obj, preferredType)</code>：</p>
<ul>
<li><code>JS</code> 引擎内部转换为原始值，该函数接受两个参数</li>
<li><code>obj</code> 为被转换的对象</li>
<li><code>preferredType</code> 为希望转换成的类型（默认为空，接受的值为 <code>Number</code> 或 <code>String</code>）</li>
</ul>
<blockquote>
<p>注意：在执行时若第二个参数为空且 <code>obj</code> 为 <code>Date</code> 的实例时，此时 <code>preferredType</code> 会被设置为 <code>String</code>，其他情况下 <code>preferredType</code> 会被设置为 <code>Number</code></p>
<p>若没有提供这个值即预设情况，则会被设置转换的 <code>hint</code> 值为 <code>default</code>，这个首选的转换原始类型的指示(<code>hint</code> 值)，是在作内部转换时由 <code>JS</code> 视情况自动加上的，一般情况就是预设值</p>
</blockquote>
<p>对象发生到基本类型值的转换时，会按照下面的逻辑调用对象上的方法：</p>
<ul>
<li><p>若存在 <code>obj[Symbol.toPrimitive]</code>，则先调用 <code>obj[Symbol.toPrimitive]</code></p>
</li>
<li><p>否则按下面规则来：</p>
<p>若 <code>preferredType</code> 为 <code>Number</code>，<code>ToPrimitive</code> 执行过程如下：</p>
<ul>
<li>若 <code>obj</code> 为原始值，直接返回</li>
<li>否则调用 <code>obj.valueOf()</code>，若执行结果是原始值则返回</li>
<li>否则调用 <code>obj.toString()</code>，若执行结果是原始值则返回</li>
<li>否则，抛出 <code>TypeError</code> 错误</li>
</ul>
<p>若 <code>preferredType</code> 为 <code>String</code>，将上面的第 <code>2</code> 步和第 <code>3</code> 步调换，即：</p>
<ul>
<li>若 <code>obj</code> 为原始值，直接返回</li>
<li>否则调用 <code>obj.toString()</code>，若执行结果是原始值则返回</li>
<li>否则调用 <code>obj.valueOf()</code>，若执行结果是原始值则返回</li>
<li>否则，抛出 <code>TypeError</code> 错误</li>
</ul>
<p><code>PreferredType</code> 没提供时即 <code>hint</code> 为 <code>default</code> 时，此时与 <code>PreferredType</code> 为数字 <code>Number</code> 时的步骤相同</p>
</li>
</ul>
<h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><p><code>Symbol.toPrimitive</code> 是一个内置的 <code>Symbol</code> 值，它是作为对象的函数值属性存在的，当一个对象转换为对应的原始值时，会调用此函数</p>
<p>该函数被调用时会被传递一个字符串参数 <code>hint</code>，表示要转换到的原始值的预期类型。<code>hint</code> 参数的取值是 <code>&quot;number&quot;</code>、<code>&quot;string&quot;</code> 和 <code>&quot;default&quot;</code> 中的任意一个</p>
<blockquote>
<p>注意：<code>Symbol.toPrimitive</code> 在类型转换方面优先级是最高的</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例 1</span></span><br><span class="line"><span class="keyword">let</span> ab = &#123;</span><br><span class="line">  <span class="title function_">valueOf</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + ab); <span class="comment">// 3</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span> + ab); <span class="comment">// 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 2</span></span><br><span class="line"><span class="comment">// 拥有 Symbol.toPrimitive 属性的对象</span></span><br><span class="line"><span class="keyword">var</span> obj2 = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span>(hint == <span class="string">&quot;number&quot;</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hint == <span class="string">&quot;string&quot;</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+obj2); <span class="comment">// 10    --hint in &quot;number&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`<span class="subst">$&#123;obj2&#125;</span>`</span>); <span class="comment">// hello --hint is &quot;string&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj2 + <span class="string">&quot;&quot;</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例 3</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">toPrimitive</span>](hint) &#123;</span><br><span class="line">    <span class="keyword">if</span>(hint === <span class="string">&#x27;number&#x27;</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Number场景&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hint === <span class="string">&#x27;string&#x27;</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;String场景&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;str&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(hint === <span class="string">&#x27;default&#x27;</span>)&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Default 场景&#x27;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;default&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>*obj); <span class="comment">// Number场景 246</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span> + obj); <span class="comment">// Default 场景 3default</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj + <span class="string">&quot;&quot;</span>);  <span class="comment">// Default场景 default</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">String</span>(obj)); <span class="comment">// String场景 str</span></span><br></pre></td></tr></table></figure>

<h3 id="valueOf-与-toString-方法"><a href="#valueOf-与-toString-方法" class="headerlink" title="valueOf 与 toString 方法"></a>valueOf 与 toString 方法</h3><p>在 <code>JS</code> 的 <code>Object</code> 原型的设计中，一定会有 <code>valueOf</code> 与 <code>toString</code> 方法，所以这两个方法在所有对象里都会有，不过它们在转换过程中有可能会交换被调用的顺序</p>
<p>对于原始类型数据，<code>toString</code> 及 <code>valueOf</code> 方法的使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;hello&quot;</span>, n = <span class="number">123</span>, bool = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(str.<span class="title function_">toString</span>()) + <span class="string">&quot;_&quot;</span> + str.<span class="title function_">toString</span>()) <span class="comment">// string_hello</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(n.<span class="title function_">toString</span>()) + <span class="string">&quot;_&quot;</span> + n.<span class="title function_">toString</span>())  <span class="comment">// string_123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(bool.<span class="title function_">toString</span>()) + <span class="string">&quot;_&quot;</span> + bool.<span class="title function_">toString</span>()) <span class="comment">//string_true</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(str.<span class="title function_">valueOf</span>()) + <span class="string">&quot;_&quot;</span> + str.<span class="title function_">valueOf</span>()) <span class="comment">//string_hello</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(n.<span class="title function_">valueOf</span>()) + <span class="string">&quot;_&quot;</span> + n.<span class="title function_">valueOf</span>()) <span class="comment">//number_123</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">typeof</span>(bool.<span class="title function_">valueOf</span>()) + <span class="string">&quot;_&quot;</span> + bool.<span class="title function_">valueOf</span>()) <span class="comment">//boolean_true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// console.log(str.valueOf) =&gt; ƒ valueOf() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str.<span class="property">valueOf</span> === str) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// console.log(n.valueOf) =&gt; ƒ valueOf() &#123; [native code] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="property">valueOf</span> === n) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// bool.valueOf() =&gt; true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bool.<span class="title function_">valueOf</span>() === bool) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>toString</code> 方法对于原始类型数据而言，其效果相当于类型转换，将原始类型转为字符串</li>
<li><code>valueOf</code> 方法对于原始类型数据而言，其效果将相当于返回原数据</li>
</ul>
</blockquote>
<p>复合对象类型数据使用 <code>toString</code> 及 <code>valueOf</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">toString</span>()); <span class="comment">// [object Object] 返回对象类型</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="title function_">valueOf</span>());  <span class="comment">// &#123;&#125; 返回对象本身</span></span><br></pre></td></tr></table></figure>

<p>综合案例</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> test = &#123; </span><br><span class="line">  <span class="attr">i</span>: <span class="number">10</span>, </span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">i</span>; </span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">valueOf</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;valueOf&#x27;</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">i</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="title function_">alert</span>(test); <span class="comment">// 10 toString </span></span><br><span class="line"><span class="title function_">alert</span>(+test); <span class="comment">// 10 valueOf </span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;&#x27;</span>+test); <span class="comment">// 10 valueOf </span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">String</span>(test)); <span class="comment">// 10 toString </span></span><br><span class="line"><span class="title function_">alert</span>(<span class="title class_">Number</span>(test)); <span class="comment">// 10 valueOf </span></span><br><span class="line"><span class="title function_">alert</span>(test == <span class="string">&#x27;10&#x27;</span>); <span class="comment">// true valueOf </span></span><br><span class="line"><span class="title function_">alert</span>(test === <span class="string">&#x27;10&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="toString-和-String-的区别"><a href="#toString-和-String-的区别" class="headerlink" title="toString() 和 String() 的区别"></a>toString() 和 String() 的区别</h3><p>它们都可以转换为<code>字符串</code>类型，区别如下：</p>
<p><code>toString()</code></p>
<ul>
<li><p><code>toString()</code> 可将所有的数据都转换为字符串，但要排除 <code>null</code> 和 <code>undefined</code>，<code>null</code> 和 <code>undefined </code>调用 <code>toString()</code> 方法会报错</p>
</li>
<li><p>若当前数据为数字类型，则 <code>toString()</code> 括号中可以写一个数字代表进制，可以将数字转化为对应进制的字符串</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">123</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>() + <span class="string">&#x27;_&#x27;</span> + <span class="title function_">typeof</span>(num.<span class="title function_">toString</span>()));   <span class="comment">// 123_string   </span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">2</span>) + <span class="string">&#x27;_&#x27;</span> + <span class="title function_">typeof</span>(num.<span class="title function_">toString</span>()));    <span class="comment">// 1111011_string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">8</span>) + <span class="string">&#x27;_&#x27;</span> + <span class="title function_">typeof</span>(num.<span class="title function_">toString</span>()));    <span class="comment">// 173_string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num.<span class="title function_">toString</span>(<span class="number">16</span>) + <span class="string">&#x27;_&#x27;</span> + <span class="title function_">typeof</span>(num.<span class="title function_">toString</span>()));   <span class="comment">//7b_string</span></span><br></pre></td></tr></table></figure>

<p><code>String()</code></p>
<ul>
<li><code>String()</code> 可以将 <code>null</code> 和 <code>undefined</code> 转换为字符串，但没法转进制字符串</li>
</ul>
<blockquote>
<p>注意下面两点：</p>
<ul>
<li><code>Symbol.toPrimitive</code> 和 <code>toString</code> <code>方法的返回值必须是基本类型值；valueOf</code> 方法除了可以返回基本类型值，也可以返回其他类型值</li>
<li>数字其实是预设的首选类型，即在一般情况下加号运算中的对象要作转型时都是先调用 <code>valueOf</code> 再调用 <code>toString</code></li>
</ul>
</blockquote>
<h2 id="运算规则"><a href="#运算规则" class="headerlink" title="&#x3D;&#x3D; 运算规则"></a>&#x3D;&#x3D; 运算规则</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">null</span>  <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="string">&quot;&quot;</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">false</span> == &#123;&#125; <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == &#123;&#125; <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">null</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">undefined</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> == &#123;&#125; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非常规</span></span><br><span class="line"><span class="string">&quot;0&quot;</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line">[] == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == <span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;&quot;</span> == [] <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == [] <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>总结：</p>
<ul>
<li><code>undefined == null</code>，结果是 <code>true</code> 且它俩与所有其他值比较的结果都是 <code>false</code>（<code>undefined</code> 和 <code>null</code> 是一对特殊的值，它们不会被自动转换成布尔值进行比较）</li>
<li><code>NaN</code> 不等于任何包括自身</li>
<li><code>String == Boolean</code>，需两个操作数同时转为 <code>Number</code></li>
<li><code>String/Boolean == Number</code>，需 <code>String/Boolean</code> 转为 <code>Number</code></li>
<li><code>Object == Primitive</code>，需 <code>Object</code> 转为 <code>Primitive</code>（具体通过 <code>valueOf</code> 和 <code>toString</code> 方法）</li>
</ul>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/type_transform.6pnmond9t3.webp" alt="&#x3D;&#x3D; 运算规则"></p>
<p>对 <code>==</code> 两边的值认真推敲，以下两个原则可以有效地避免出错，这时最好用 <code>===</code> 来避免不经意的强制类型转换</p>
<ul>
<li>若两边的值中有 <code>true</code> 或 <code>false</code>，千万不要使用 <code>==</code></li>
<li>若两边的值中有 <code>[]</code>、<code>&quot;&quot;</code> 或 <code>0</code>，尽量不要使用 <code>==</code></li>
</ul>
<h2 id="、-和-Object-is-的区别"><a href="#、-和-Object-is-的区别" class="headerlink" title="&#x3D;&#x3D;、&#x3D;&#x3D;&#x3D; 和 Object.is() 的区别"></a>&#x3D;&#x3D;、&#x3D;&#x3D;&#x3D; 和 Object.is() 的区别</h2><p><code>==</code>：等于，<code>===</code>：严格等于，<code>Object.is()</code>：加强版严格等于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">3</span>; </span><br><span class="line"><span class="keyword">const</span> b = <span class="string">&quot;3&quot;</span>; </span><br><span class="line">a == b;    <span class="comment">// true</span></span><br><span class="line">a === b;   <span class="comment">// false，因为 a、b 的类型不一样 </span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(a, b);  <span class="comment">// false，因为 a、b 的类型不一样 </span></span><br></pre></td></tr></table></figure>

<p><code>===</code> 这个比较简单，只需利用下面的规则来判断两个值是否恒等</p>
<ul>
<li>若类型不同，就不相等</li>
<li>若两个都是数值且是同一个值则相等，有一个是 <code>NaN</code> 就不相等</li>
<li>若两个都是字符串且每个位置的字符都一样则相等，否则不相等</li>
<li>若两个值都是同样的 <code>Boolean</code> 值则相等</li>
<li>若两个值都引用同一个对象或函数则相等，即两个对象的物理地址也须保持一致，否则不相等</li>
<li>若两个值都是 <code>null</code> 或都是 <code>undefined</code> 则相等</li>
</ul>
<p><code>Object.is()</code> 其行为与 <code>===</code> 基本一致，不过有两处不同：</p>
<ul>
<li><code>+0</code> 不等于 <code>-0</code></li>
<li><code>NaN</code> 等于自身</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line"><span class="title class_">NaN</span> === <span class="title class_">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">0</span>, +<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(-<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="number">0</span>/<span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="title class_">NaN</span>, <span class="title class_">NaN</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;foo&#x27;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="variable language_">window</span>, <span class="variable language_">window</span>); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;bar&#x27;</span>); <span class="comment">// false</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>([], []); <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> foo = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> bar = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(foo, foo); <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(foo, bar); <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">is</span>(<span class="literal">null</span>, <span class="literal">null</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>Object.is()</code> 在严格等于的基础上修复了一些特殊情况下的失误，即 <code>+0</code> 和 <code>-0</code>，<code>NaN</code> 和 <code>NaN</code></p>
</blockquote>
<p>模拟实现 <code>Object.is()</code> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectIs</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(x === y) &#123;</span><br><span class="line">    <span class="comment">// 运行到 1/x === 1/y 时 x 和 y 都为 0</span></span><br><span class="line">    <span class="comment">// 但 1/+0 = +Infinity，1/-0 = -Infinity 是不一样的</span></span><br><span class="line">    <span class="keyword">return</span> x !== <span class="number">0</span> || y !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// NaN === NaN 是 false，在这里做个拦截，x !== x 一定是 NaN, y 同理</span></span><br><span class="line">    <span class="comment">// 两个都是 NaN 时返回 true</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="JS-对于-Object-与-Array-的设计"><a href="#JS-对于-Object-与-Array-的设计" class="headerlink" title="JS 对于 Object 与 Array 的设计"></a>JS 对于 Object 与 Array 的设计</h2><p>在 <code>JS</code> 中所设计的 <code>Object</code> 纯对象类型的 <code>valueOf</code> 与 <code>toString</code> 方法，它们的返回如下：</p>
<ul>
<li><p><code>valueOf</code> 方法：对象本身</p>
</li>
<li><p><code>toString</code> 方法：<code>&quot;[object Object]&quot;</code> 字符串值，不同的内建对象的返回值是 <code>&quot;[object type]&quot;</code> 字符串</p>
<ul>
<li><code>type</code> 指的是对象本身的类型识别，如 <code>Math</code> 对象是返回 <code>&quot;[object Math]&quot;</code> 字符串</li>
<li>但有些内置对象因为覆盖了这个方法，所以直接调用时不是这种值（注意：这个返回字符串的前面的 <code>&quot;object&quot;</code> 开头英文是小写，后面开头英文是大写）</li>
</ul>
</li>
</ul>
<p>因此可利用 <code>Object</code> 中的 <code>toString</code> 来进行各种不同对象进行判断，这在以前 <code>JS</code> 能用的函数库或方法不多的年代经常看到，不过它需要配合使用函数中的 <code>call</code> 方法才能输出正确的对象类型值，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>([]); <span class="comment">// &quot;[object Array]&quot;</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Date</span>); <span class="comment">// &quot;[object Date]&quot;</span></span><br></pre></td></tr></table></figure>

<p>对象的这两个方法均可被覆盖，可用下面的代码来观察这两个方法的运行顺序，下面这个都是先调用 <code>valueOf</code> 的情况：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">valueOf</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;valueOf&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;; <span class="comment">// object</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;obj&#x27;</span>; <span class="comment">// string</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span> + obj);  <span class="comment">//valueOf -&gt; toString -&gt; &#x27;1obj&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+obj); <span class="comment">// // valueOf -&gt; toString -&gt; NaN</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;&#x27;</span> + obj); <span class="comment">// valueOf -&gt; toString -&gt; &#x27;obj&#x27;</span></span><br></pre></td></tr></table></figure>

<p>先调用 <code>toString</code> 的情况比较少见，大概只有 <code>Date</code> 对象或强制要转换为字符串时才会看到：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">valueOf</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;valueOf&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// number</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;; <span class="comment">// object</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(obj); <span class="comment">// toString -&gt; valueOf -&gt; alert(&quot;1&quot;);</span></span><br><span class="line"><span class="title class_">String</span>(obj); <span class="comment">// toString -&gt; valueOf -&gt; &quot;1&quot;;</span></span><br></pre></td></tr></table></figure>

<p>而下面这个例子会造成错误，因为不论顺序如何都得不到原始数据类型的值，错误消息是<code>TypeError: Cannot convert object to primitive value</code>，从这个消息中可以得知它这里面会需要转换对象到原始数据类型：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">valueOf</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;valueOf&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;; <span class="comment">// object</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">toString</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;toString&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;; <span class="comment">// object</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj + obj); <span class="comment">// valueOf -&gt; toString -&gt; error!</span></span><br></pre></td></tr></table></figure>

<p>数组 <code>Array</code> 很常用，虽然它是个对象类型，但它与 <code>Object</code> 的设计不同，它的 <code>toString</code> 有覆盖，说明一下数组的 <code>valueOf</code> 与 <code>toString</code> 的两个方法的返回值：</p>
<ul>
<li><code>valueOf</code> 方法：对象本身（与 <code>Object</code> 一样）</li>
<li><code>toString</code> 方法：相当于用数组值调用 <code>join(&#39;,&#39;)</code> 所返回的字符串，即 <code>[1,2,3].toString()</code> 会是 <code>&quot;1,2,3&quot;</code>，这点要特别注意</li>
</ul>
<p><code>Function</code> 对象很少会用到，它的 <code>toString</code> 也有被覆盖，所以并不是 <code>Object</code> 中的那个 <code>toString</code>，<code>Function</code> 对象的 <code>valueOf</code> 与 <code>toString</code> 的两个方法的返回值：</p>
<ul>
<li><code>valueOf</code> 方法：对象本身（与 <code>Object</code> 一样）</li>
<li><code>toString</code> 方法：函数中包含的代码转为字符串值</li>
</ul>
<h2 id="的结果是什么？"><a href="#的结果是什么？" class="headerlink" title="{} + [] 的结果是什么？"></a>{} + [] 的结果是什么？</h2><p>详见：<a href="https://donnapersonal.github.io/posts/+operator/cn">JS 的 {} + {} 与 {} + [] 的结果是什么？</a></p>
<h2 id="1-2-3-map-parseInt-的返回值是什么？"><a href="#1-2-3-map-parseInt-的返回值是什么？" class="headerlink" title="[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)的返回值是什么？"></a>[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)的返回值是什么？</h2><p>详见：<a href="https://donnapersonal.github.io/posts/map-parseint/cn">[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)的返回值是什么？</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://donnapersonal.github.io/cn">Donna Tang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://donnapersonal.github.io/cn/posts/jsbasic-datatype/">https://donnapersonal.github.io/cn/posts/jsbasic-datatype/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://donnapersonal.github.io/cn" target="_blank">Donna'Log</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/cn/tags/JS/">JS</a></div><div class="post-share"><div class="social-share" data-image="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.7i0rgcc8cp.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/cn/posts/0.1+0.2/" title="为什么 0.1 + 0.2 !== 0.3"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.6m494gp9dv.webp" onerror="onerror=null;src='/cn/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">为什么 0.1 + 0.2 !== 0.3</div></div><div class="info-2"><div class="info-item-1">背景在浏览器控制台窗口输入以下两行代码，结果出乎意料 1230.1 + 0.2 &gt; 0.3  // true0.1 + 0.2 = 0.300000000000000040.1 * 0.1 = 0.010000000000000002  前置知识在计算机的世界里，应该是只有二进制数据的，不是 0 就是 1，为了表达生活中最为常见的十进制数据，则就会有个转换过程 十进制转为二进制十进制转换为二进制这个过程整体总结就是：  整数采用整数除 2 取余，直到商为 0 时为止，将余数逆序排列 小数采用小数部分乘以 2，取整，直到得到小数部分 0 或达到所要求的精度为止，将整数顺序排列  二进制转为十进制12345678910111213// 以二进制 10101101.1101 为例  // 针对整数部分 10101101 计算逻辑如下// ← 从右往左1 * 2^0 + 0 * 2^1 + 1 * 2^2 + 1 * 2^3 + 0 * 2^4 + 1 * 2^5 + 0 * 2^6 + 1 * 2^7= 1 + 0 + 4 + 8 + 0 + 32 + 0 + 128= 173/...</div></div></div></a><a class="pagination-related" href="/cn/posts/+operator/" title="JS 的 {} + {} 与 {} + [] 的结果是什么？"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.8s3omkauw3.webp" onerror="onerror=null;src='/cn/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">JS 的 {} + {} 与 {} + [] 的结果是什么？</div></div><div class="info-2"><div class="info-item-1">前言在 JS 中，+ 符号是很常见的一种，它有以下的使用情况：  数字的加法运算，二元运算 字符串的连接运算，二元运算，优先级最高 正号，一元运算，可延伸为强制转换其他类型的运算元为数字类型  另一个常见的是花括号 &#123;&#125;，它有两个用途也很常见：  对象的字面定义 区块语句  加号运算符 +除了上面说明的常见情况外，在标准中转换的规则还有以下几个，要注意它的顺序：operand + operand = result  使用 ToPrimitive 运算转换左与右运算元为原始数据类型值 (primitive) 在第 1 步转换后，若有运算元出现原始数据类型是&quot;字符串&quot;类型值时，则另一运算元作强制转换为字符串，然后作字符串的连接运算 (concatenation) 其他情况时，所有运算元都会转换为原始数据类型的&quot;数字&quot;类型，然后作数学的相加运算(addition)  ToPrimitive 内部运算因此，加号运算符只能使用于原始数据类型，那么对于对象类型的值要如何转换为原始数据类型？ JavaScript 对象转换到基本类型值...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/cn/posts/+operator/" title="JS 的 {} + {} 与 {} + [] 的结果是什么？"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.8s3omkauw3.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="info-item-2">JS 的 {} + {} 与 {} + [] 的结果是什么？</div></div><div class="info-2"><div class="info-item-1">前言在 JS 中，+ 符号是很常见的一种，它有以下的使用情况：  数字的加法运算，二元运算 字符串的连接运算，二元运算，优先级最高 正号，一元运算，可延伸为强制转换其他类型的运算元为数字类型  另一个常见的是花括号 &#123;&#125;，它有两个用途也很常见：  对象的字面定义 区块语句  加号运算符 +除了上面说明的常见情况外，在标准中转换的规则还有以下几个，要注意它的顺序：operand + operand = result  使用 ToPrimitive 运算转换左与右运算元为原始数据类型值 (primitive) 在第 1 步转换后，若有运算元出现原始数据类型是&quot;字符串&quot;类型值时，则另一运算元作强制转换为字符串，然后作字符串的连接运算 (concatenation) 其他情况时，所有运算元都会转换为原始数据类型的&quot;数字&quot;类型，然后作数学的相加运算(addition)  ToPrimitive 内部运算因此，加号运算符只能使用于原始数据类型，那么对于对象类型的值要如何转换为原始数据类型？ JavaScript 对象转换到基本类型值...</div></div></div></a><a class="pagination-related" href="/cn/posts/0.1+0.2/" title="为什么 0.1 + 0.2 !&#x3D;&#x3D; 0.3"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.6m494gp9dv.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="info-item-2">为什么 0.1 + 0.2 !&#x3D;&#x3D; 0.3</div></div><div class="info-2"><div class="info-item-1">背景在浏览器控制台窗口输入以下两行代码，结果出乎意料 1230.1 + 0.2 &gt; 0.3  // true0.1 + 0.2 = 0.300000000000000040.1 * 0.1 = 0.010000000000000002  前置知识在计算机的世界里，应该是只有二进制数据的，不是 0 就是 1，为了表达生活中最为常见的十进制数据，则就会有个转换过程 十进制转为二进制十进制转换为二进制这个过程整体总结就是：  整数采用整数除 2 取余，直到商为 0 时为止，将余数逆序排列 小数采用小数部分乘以 2，取整，直到得到小数部分 0 或达到所要求的精度为止，将整数顺序排列  二进制转为十进制12345678910111213// 以二进制 10101101.1101 为例  // 针对整数部分 10101101 计算逻辑如下// ← 从右往左1 * 2^0 + 0 * 2^1 + 1 * 2^2 + 1 * 2^3 + 0 * 2^4 + 1 * 2^5 + 0 * 2^6 + 1 * 2^7= 1 + 0 + 4 + 8 + 0 + 32 + 0 + 128= 173/...</div></div></div></a><a class="pagination-related" href="/cn/posts/jsbasic-handwriting/" title="JavaScript 基础 - 高频手写"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9ddc96s40g.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-09</div><div class="info-item-2">JavaScript 基础 - 高频手写</div></div><div class="info-2"><div class="info-item-1">模拟 Object.is()Object.is() 在 === 的基础上修复了一些特殊情况下的失误，具体来说就是：  +0 不等于 -0 NaN 等于自身  1234567891011function objectIs(x, y) &#123;  if(x === y) &#123;    // 运行到 1/x === 1/y 时 x 和 y 都为 0    // 但 1/+0 = +Infinity，1/-0 = -Infinity 是不一样的    return x !== 0 || y !== 0 || 1 / x === 1 / y;  &#125; else &#123;    // NaN === NaN 是 false，在这里做个拦截，x !== x 一定是 NaN, y 同理    // 两个都是 NaN 时返回 true    return x !== x &amp;&amp; y !== y;  &#125;&#125;  模拟 new当执行 new Foo(...) 时，会发生以下事情：  一个继承自 Foo.prototype 的新对象被创建 使用指定的参...</div></div></div></a><a class="pagination-related" href="/cn/posts/jsbasic-inherit/" title="JavaScript 基础 - 继承"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2rvii9f6z2.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="info-item-2">JavaScript 基础 - 继承</div></div><div class="info-2"><div class="info-item-1">继承原型存在的意义就是组成原型链：引用类型皆对象，每个对象都有原型，原型也是对象，也有它自己的原型，一层一层的组成了原型链 原型链存在的意义就是继承：访问对象属性时，在对象本身找不到，就在原型链上一层一层往上找，说白了就是一个对象可以访问其他对象的属性 继承存在的意义就是属性共享：  好处一是代码重用（字面意思） 好处二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性  ES5 继承实现方式原型链继承原理：将父类的实例作为子类的原型 12345678910111213141516171819202122232425function Parent() &#123;  this.name = &#x27;tn&#x27;;&#125;Parent.prototype.getName = function () &#123;  console.log(this.name);&#125;function Son () &#123;&#125;;// 关键，创建 Parent 的实例并将该实例赋值给 Son.prototypeSon.prototype = new Pare...</div></div></div></a><a class="pagination-related" href="/cn/posts/jsbasic-prototype/" title="JavaScript 基础 - 重新认识构造函数、原型、原型链、继承"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.73ubpkycwk.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="info-item-2">JavaScript 基础 - 重新认识构造函数、原型、原型链、继承</div></div><div class="info-2"><div class="info-item-1">构造函数什么是构造函数构造函数 就是提供一个生成对象的模板并描述对象基本结构的函数。一个构造函数可以生成多个对象，这些对象都有相同的结构  构造函数 本身就是一个函数，不过为了规范一般将其首字母大写  构造函数 和 普通函数 的区别在于使用 new 生成实例的函数就是构造函数，直接调用的就是普通函数   生成对象实例时必须使用 new 命令来调用构造函数，所以构造函数更合理的理解应该是函数的构造调用 constructor 返回创建实例对象时构造函数的引用，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串 1234567function Person(age) &#123;  this.age = age;&#125;var p = new Person(18);p.constructor === Person; // truep.constructor === Object; // false  那普通函数创建的实例是不是一定没有 constructor 属性呢？不一定 12345678910111213141516// 普通函数function person(ag...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/cn/img/avatar.JPG" onerror="this.onerror=null;this.src='/cn/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Donna Tang</div><div class="author-info-description">Learn more! Think more! Do more!</div><div class="site-data"><a href="/cn/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/cn/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/cn/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/donnapersonal"><i class="fab fa-github"></i><span>GitHub</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog! <br>Migrating from old blog!</br></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%EF%BC%88Primitive%EF%BC%89%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">原始（Primitive）类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined-%E5%92%8C-null-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.1.</span> <span class="toc-text">undefined 和 null 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof-null-%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-object"><span class="toc-number">1.1.2.</span> <span class="toc-text">typeof null 的结果为什么是 object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-0-1-0-2-0-3%EF%BC%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">为什么 0.1 + 0.2 !&#x3D;&#x3D; 0.3？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E6%98%AF-NaN%EF%BC%9F"><span class="toc-number">1.1.4.</span> <span class="toc-text">如何判断一个数据是 NaN？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89-BigInt-%E7%9A%84%E6%8F%90%E6%A1%88%EF%BC%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">为什么会有 BigInt 的提案？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">引用类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.</span> <span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E6%98%AF%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%EF%BC%89"><span class="toc-number">2.1.</span> <span class="toc-text">算术运算符（算术运算符的优先级是从左到右的）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">比较运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.</span> <span class="toc-text">逻辑运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.</span> <span class="toc-text">类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.</span> <span class="toc-text">显示类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.2.</span> <span class="toc-text">隐式类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-number">3.3.</span> <span class="toc-text">转换规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">引用类型转换为原始类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ToPrimitive"><span class="toc-number">3.4.1.</span> <span class="toc-text">[[ToPrimitive]]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Symbol-toPrimitive"><span class="toc-number">3.4.2.</span> <span class="toc-text">Symbol.toPrimitive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#valueOf-%E4%B8%8E-toString-%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.3.</span> <span class="toc-text">valueOf 与 toString 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#toString-%E5%92%8C-String-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.4.4.</span> <span class="toc-text">toString() 和 String() 的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E8%A7%84%E5%88%99"><span class="toc-number">3.5.</span> <span class="toc-text">&#x3D;&#x3D; 运算规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E3%80%81-%E5%92%8C-Object-is-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.</span> <span class="toc-text">&#x3D;&#x3D;、&#x3D;&#x3D;&#x3D; 和 Object.is() 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">4.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-%E5%AF%B9%E4%BA%8E-Object-%E4%B8%8E-Array-%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.1.</span> <span class="toc-text">JS 对于 Object 与 Array 的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">{} + [] 的结果是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-3-map-parseInt-%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.3.</span> <span class="toc-text">[&#39;1&#39;,&#39;2&#39;,&#39;3&#39;].map(parseInt)的返回值是什么？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/jsbasic-handwriting/" title="JavaScript 基础 - 高频手写"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9ddc96s40g.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="JavaScript 基础 - 高频手写"/></a><div class="content"><a class="title" href="/cn/posts/jsbasic-handwriting/" title="JavaScript 基础 - 高频手写">JavaScript 基础 - 高频手写</a><time datetime="2021-07-10T01:10:53.000Z" title="发表于 2021-07-09 21:10:53">2021-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/jsbasic-inherit/" title="JavaScript 基础 - 继承"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2rvii9f6z2.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="JavaScript 基础 - 继承"/></a><div class="content"><a class="title" href="/cn/posts/jsbasic-inherit/" title="JavaScript 基础 - 继承">JavaScript 基础 - 继承</a><time datetime="2021-07-09T01:10:53.000Z" title="发表于 2021-07-08 21:10:53">2021-07-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/jsbasic-prototype/" title="JavaScript 基础 - 重新认识构造函数、原型、原型链、继承"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.73ubpkycwk.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="JavaScript 基础 - 重新认识构造函数、原型、原型链、继承"/></a><div class="content"><a class="title" href="/cn/posts/jsbasic-prototype/" title="JavaScript 基础 - 重新认识构造函数、原型、原型链、继承">JavaScript 基础 - 重新认识构造函数、原型、原型链、继承</a><time datetime="2021-07-09T01:10:53.000Z" title="发表于 2021-07-08 21:10:53">2021-07-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/0.1+0.2/" title="为什么 0.1 + 0.2 !== 0.3"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.6m494gp9dv.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="为什么 0.1 + 0.2 !== 0.3"/></a><div class="content"><a class="title" href="/cn/posts/0.1+0.2/" title="为什么 0.1 + 0.2 !== 0.3">为什么 0.1 + 0.2 !== 0.3</a><time datetime="2021-05-17T01:35:51.000Z" title="发表于 2021-05-16 21:35:51">2021-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/jsbasic-datatype/" title="JavaScript 基础 - 数据类型、运算符、类型转换"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.7i0rgcc8cp.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="JavaScript 基础 - 数据类型、运算符、类型转换"/></a><div class="content"><a class="title" href="/cn/posts/jsbasic-datatype/" title="JavaScript 基础 - 数据类型、运算符、类型转换">JavaScript 基础 - 数据类型、运算符、类型转换</a><time datetime="2021-05-16T19:49:09.000Z" title="发表于 2021-05-16 15:49:09">2021-05-16</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By Donna Tang</span></div><div class="footer_custom_text">Hi, welcome to my blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/cn/js/utils.js"></script><script src="/cn/js/main.js"></script><div class="js-pjax"></div><script data-pjax src="/self/btf.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/cn/404') : window.location.href = '/cn/404')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/cn/js/search/local-search.js"></script></div></div></body></html>
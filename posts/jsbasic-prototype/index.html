<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaScript 基础 - 重新认识构造函数、原型、原型链、继承 | Donna'Log</title><meta name="author" content="Donna Tang"><meta name="copyright" content="Donna Tang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="构造函数什么是构造函数构造函数 就是提供一个生成对象的模板并描述对象基本结构的函数。一个构造函数可以生成多个对象，这些对象都有相同的结构  构造函数 本身就是一个函数，不过为了规范一般将其首字母大写  构造函数 和 普通函数 的区别在于使用 new 生成实例的函数就是构造函数，直接调用的就是普通函数   生成对象实例时必须使用 new 命令来调用构造函数，所以构造函数更合理的理解应该是函数的构造调">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 基础 - 重新认识构造函数、原型、原型链、继承">
<meta property="og:url" content="https://donnapersonal.github.io/cn/posts/jsbasic-prototype/">
<meta property="og:site_name" content="Donna&#39;Log">
<meta property="og:description" content="构造函数什么是构造函数构造函数 就是提供一个生成对象的模板并描述对象基本结构的函数。一个构造函数可以生成多个对象，这些对象都有相同的结构  构造函数 本身就是一个函数，不过为了规范一般将其首字母大写  构造函数 和 普通函数 的区别在于使用 new 生成实例的函数就是构造函数，直接调用的就是普通函数   生成对象实例时必须使用 new 命令来调用构造函数，所以构造函数更合理的理解应该是函数的构造调">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.73ubpkycwk.webp">
<meta property="article:published_time" content="2021-07-09T01:10:53.000Z">
<meta property="article:modified_time" content="2025-10-03T01:48:43.959Z">
<meta property="article:author" content="Donna Tang">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.73ubpkycwk.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JavaScript 基础 - 重新认识构造函数、原型、原型链、继承",
  "url": "https://donnapersonal.github.io/cn/posts/jsbasic-prototype/",
  "image": "https://github.com/donnapersonal/picx-images-hosting/raw/master/image.73ubpkycwk.webp",
  "datePublished": "2021-07-09T01:10:53.000Z",
  "dateModified": "2025-10-03T01:48:43.959Z",
  "author": [
    {
      "@type": "Person",
      "name": "Donna Tang",
      "url": "https://donnapersonal.github.io/cn"
    }
  ]
}</script><link rel="shortcut icon" href="/cn/img/favicon.png"><link rel="canonical" href="https://donnapersonal.github.io/cn/posts/jsbasic-prototype/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/cn/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/cn/',
  algolia: undefined,
  localSearch: {"path":"/cn/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Donna Tang","link":"链接: ","source":"来源: Donna'Log","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript 基础 - 重新认识构造函数、原型、原型链、继承',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://oss.012700.xyz/butterfly/2024/10/index.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/cn/img/avatar.JPG" onerror="this.onerror=null;this.src='/cn/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/cn/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/cn/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/cn/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/cn/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/cn/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/cn/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/cn/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://donnapersonal.github.io/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/cn/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/cn/"><span class="site-name">Donna'Log</span></a><a class="nav-page-title" href="/cn/"><span class="site-name">JavaScript 基础 - 重新认识构造函数、原型、原型链、继承</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/cn/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/cn/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/cn/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/cn/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://donnapersonal.github.io/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/cn/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JavaScript 基础 - 重新认识构造函数、原型、原型链、继承<a class="post-edit-link" href="null_posts/jsbasic-prototype.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-09T01:10:53.000Z" title="发表于 2021-07-08 21:10:53">2021-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-03T01:48:43.959Z" title="更新于 2025-10-02 21:48:43">2025-10-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/cn/categories/Frontend/">Frontend</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/cn/categories/Frontend/JS/">JS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><h2 id="什么是构造函数"><a href="#什么是构造函数" class="headerlink" title="什么是构造函数"></a>什么是构造函数</h2><p><code>构造函数</code> 就是提供一个生成对象的模板并描述对象基本结构的函数。一个构造函数可以生成多个对象，这些对象都有相同的结构</p>
<blockquote>
<p><code>构造函数</code> 本身就是一个函数，不过为了规范一般将其首字母大写</p>
<ul>
<li><code>构造函数</code> 和 <code>普通函数</code> 的区别在于使用 <code>new</code> 生成实例的函数就是构造函数，直接调用的就是普通函数</li>
</ul>
</blockquote>
<p>生成对象实例时必须使用 <code>new</code> 命令来调用构造函数，所以构造函数更合理的理解应该是函数的构造调用</p>
<p><code>constructor</code> 返回创建实例对象时构造函数的引用，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>);</span><br><span class="line">p.<span class="property">constructor</span> === <span class="title class_">Person</span>; <span class="comment">// true</span></span><br><span class="line">p.<span class="property">constructor</span> === <span class="title class_">Object</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>那普通函数创建的实例是不是一定没有 <code>constructor</code> 属性呢？不一定</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="title function_">person</span>(<span class="number">20</span>); <span class="comment">// undefined</span></span><br><span class="line">p.<span class="property">constructor</span>; <span class="comment">// Cannot read property &#x27;constructor&#x27; of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">person</span>(<span class="params">age</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">age</span>: age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="title function_">person</span>(<span class="number">20</span>);</span><br><span class="line">p.<span class="property">constructor</span> === <span class="title class_">Object</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h2 id="Symbol-是否是构造函数"><a href="#Symbol-是否是构造函数" class="headerlink" title="Symbol 是否是构造函数"></a>Symbol 是否是构造函数</h2><p><code>MDN</code> 这样介绍：</p>
<blockquote>
<p>The Symbol() function returns a value of type symbol, has static properties that expose several members of built-in objects, has static methods that expose the global symbol registry, and resembles a built-in object class but is incomplete as a constructor because it does not support the syntax &quot;new Symbol()&quot;</p>
</blockquote>
<p><code>Symbol</code> 是基本数据类型，但作为构造函数来说它并不完整，因为它不支持语法 <code>new Symbol()</code>，因此认为其不是构造函数，若要生成实例直接使用 <code>Symbol()</code> 即可（来自 <code>MDN</code>），<strong>每个从 <code>Symbol()</code> 返回的值都是唯一的</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Symbol</span>(<span class="number">1</span>); <span class="comment">// Symbol is not a constructor </span></span><br><span class="line"><span class="title class_">Symbol</span>(<span class="number">1</span>); <span class="comment">// Symbol(1)</span></span><br></pre></td></tr></table></figure>

<p>虽然是基本数据类型，但 <code>Symbol(1)</code> 实例可以获取 <code>constructor</code> 属性值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Symbol</span>(<span class="number">1</span>);  <span class="comment">// Symbol(1)</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="property">constructor</span>); <span class="comment">// ƒ Symbol() &#123; [native code] &#125;</span></span><br></pre></td></tr></table></figure>

<p>这里的 <code>constructor</code> 属性其实是 <code>Symbol</code> 原型上的，即 <code>Symbol.prototype.constructor</code> 返回创建实例原型的函数，默认为 <code>Symbol</code> 函数</p>
<h2 id="constructor-值是否只读"><a href="#constructor-值是否只读" class="headerlink" title="constructor 值是否只读"></a>constructor 值是否只读</h2><p>对于引用类型来说 <code>constructor</code> 属性值是可以修改的，但对于基本类型来说是只读的</p>
<p>引用类型情况其值可修改这个很好理解，如原型链继承方案中就需要对 <code>constructor</code> 重新赋值进行修正</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="number">42</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Bar</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 Bar 的 prototype 属性为 Foo 的实例对象</span></span><br><span class="line"><span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">foo</span> = <span class="string">&#x27;Hello JS&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> <span class="title class_">Bar</span>() <span class="comment">// 创建 Bar 的一个新实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test); </span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example1.5mnxgnu1xh.webp" alt="example1"></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修正 Bar.prototype.constructor 为 Bar 本身</span></span><br><span class="line"><span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Bar</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">new</span> <span class="title class_">Bar</span>() <span class="comment">// 创建 Bar 的一个新实例</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(test);</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example2.8z6nb1am9z.webp" alt="example2"></p>
<p>对于基本类型来说是只读的，如 <code>1</code>、<code>&quot;1&quot;</code>、<code>true</code>、<code>Symbol</code>（<code>null</code> 和 <code>undefined</code> 是没有 <code>constructor</code> 属性的）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Type</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> types = [<span class="number">1</span>, <span class="string">&quot;1&quot;</span>, <span class="literal">true</span>, <span class="title class_">Symbol</span>(<span class="number">1</span>)];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = types.<span class="property">length</span>; i &lt; len; i++) &#123;</span><br><span class="line">  types[i].<span class="property">constructor</span> = <span class="title class_">Type</span>;</span><br><span class="line">  types[i] = [types[i].<span class="property">constructor</span>, types[i] <span class="keyword">instanceof</span> <span class="title class_">Type</span>, types[i].<span class="title function_">toString</span>()];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(types.<span class="title function_">join</span>(<span class="string">&quot;\n&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example3.3k84u03o9m.webp" alt="example3"></p>
<p>为什么呢？因为创建它们的是只读的原生构造函数 <code>native constructors</code>，这个例子也说明了依赖一个对象的 <code>constructor</code> 属性并不安全</p>
<h2 id="模拟实现-new"><a href="#模拟实现-new" class="headerlink" title="模拟实现 new"></a>模拟实现 new</h2><blockquote>
<p><code>new</code> 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例（来自于 <code>MDN</code>）</p>
</blockquote>
<p>当代码 <code>new Foo(...)</code> 执行时会发生以下事情：</p>
<ul>
<li>一个继承自 <code>Foo.prototype</code> 的新对象被创建</li>
<li>使用指定的参数调用构造函数 <code>Foo</code> 并将 <code>this</code> 绑定到新创建的对象上（<code>new Foo</code> 等同于 <code>new Foo()</code>，即没有指定参数列表，<code>Foo</code> 不带任何参数调用的情况）</li>
<li>由构造函数返回的对象就是 <code>new</code> 表达式的结果，若构造函数没有显式返回一个对象，则使用步骤 <code>1</code> 创建的对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createNew</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个空的对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(); </span><br><span class="line">  <span class="comment">// 获得构造函数，arguments 中去除第一个参数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Con</span> = [].<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 链接到原型</span></span><br><span class="line">  <span class="comment">// 创建一个原型为构造器的 prototype 的空对象 obj</span></span><br><span class="line">  <span class="comment">// const obj = Object.create(constructor.prototype);  </span></span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="comment">// 绑定 this 实现继承，使用 apply 改变构造函数 this 的指向到新建的对象，这样 obj 就可以访问到构造函数中的属性</span></span><br><span class="line">  <span class="title class_">Con</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 返回对象</span></span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Car</span>(<span class="params">color</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Car</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">start</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">color</span> + <span class="string">&quot; car start&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> car = <span class="title function_">createNew</span>(<span class="title class_">Car</span>, <span class="string">&quot;black&quot;</span>);</span><br><span class="line">car.<span class="property">color</span>;</span><br><span class="line"><span class="comment">// black</span></span><br><span class="line"></span><br><span class="line">car.<span class="title function_">start</span>();</span><br><span class="line"><span class="comment">// black car start</span></span><br></pre></td></tr></table></figure>

<p>上面的代码已经实现了 <code>80%</code>，现在继续优化。构造函数返回值有如下三种情况：</p>
<ul>
<li><p>返回一个对象，<code>this</code> 失效，实例 <code>person</code> 中只能访问到返回对象中的属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">age, name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;tn&quot;</span>);</span><br><span class="line">person.<span class="property">age</span>; <span class="comment">// undefined</span></span><br><span class="line">person.<span class="property">name</span>; <span class="comment">// &quot;tn&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>没有 <code>return</code>，即返回 <code>undefined</code></p>
<p>实例 <code>person</code> 中只能访问到构造函数中的属性，和上面完全相反</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">age, name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;tn&quot;</span>);</span><br><span class="line">person.<span class="property">age</span>; <span class="comment">// 18</span></span><br><span class="line">person.<span class="property">name</span>; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回 <code>undefined</code> 以外的基本类型</p>
<p>实例 <code>person</code> 中只能访问到构造函数中的属性，和情况 <code>1</code> 相反，结果相当于没有返回值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">age, name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;new person&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="number">18</span>, <span class="string">&quot;tn&quot;</span>);</span><br><span class="line">person.<span class="property">age</span>; <span class="comment">// 18</span></span><br><span class="line">person.<span class="property">name</span>; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>所以需要判断下返回值是不是一个对象，若是对象则返回该对象，不然返回新创建的 <code>obj</code> 对象，实现代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createNew</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 创建一个空的对象</span></span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  <span class="comment">// 获得构造函数，arguments 中去除第一个参数</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Con</span> = [].<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 链接到原型，obj 可以访问到构造函数原型中的属性</span></span><br><span class="line">  obj.<span class="property">__proto__</span> = <span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="comment">// 绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">  <span class="keyword">const</span> ret = <span class="title class_">Con</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 优先返回构造函数返回的对象</span></span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可继续优化实现 <code>new</code>，这里不使用 <code>__proto__</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 1、获得构造函数，同时删除 arguments 中第一个参数</span></span><br><span class="line">  <span class="title class_">Con</span> = [].<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 2、创建一个空的对象并链接到原型，obj 可以访问构造函数原型中的属性</span></span><br><span class="line">  <span class="keyword">var</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Con</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 3、绑定 this 实现继承，obj 可以访问到构造函数中的属性</span></span><br><span class="line">  <span class="keyword">var</span> ret = <span class="title class_">Con</span>.<span class="title function_">apply</span>(obj, <span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 4、优先返回构造函数返回的对象</span></span><br><span class="line">  <span class="keyword">return</span> ret <span class="keyword">instanceof</span> <span class="title class_">Object</span> ? ret : obj;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="扩展：如何确保构造函数只能被-new-调用而不能被普通调用？"><a href="#扩展：如何确保构造函数只能被-new-调用而不能被普通调用？" class="headerlink" title="扩展：如何确保构造函数只能被 new 调用而不能被普通调用？"></a>扩展：如何确保构造函数只能被 new 调用而不能被普通调用？</h2><p><code>JS</code> 中的函数一般有两种使用方式：</p>
<ul>
<li>当作构造函数使用：<code>new Func()</code></li>
<li>当作普通函数调用：<code>Func()</code></li>
</ul>
<p>但 <code>JS</code> 内部并没有区分两者的方式，我们人为规定<strong>构造函数的函数名首字母要大写作为区分，但构造函数被当成普通函数调用不会有报错提示</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">firstName</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 new 调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;tn&quot;</span>));  <span class="comment">// Person &#123;firstName: &#x27;tn&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当作普通函数调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>(<span class="string">&quot;tn&quot;</span>));  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>使用 <code>new</code> 调用函数和普通调用函数最大的区别<strong>在于函数内部 <code>this</code> 指向不同：<code>new</code> 后 <code>this</code> 指向实例，普通调用则一般会指向 <code>window</code></strong></p>
<blockquote>
<p><code>new</code> 绑定&#x2F;默认绑定</p>
<ul>
<li>通过 <code>new</code> 来调用构造函数会生成一个新对象，且把这个新对象绑定为调用函数的 <code>this</code></li>
<li>若普通调用函数，非严格模式下 <code>this</code> 指向 <code>window</code>，严格模式下指向 <code>undefined</code></li>
</ul>
</blockquote>
<p>因此要限制构造函数只能被 <code>new</code> 调用，可以使用以下几种方案：</p>
<ul>
<li><p>借助 <code>instanceof</code> 和 <code>new</code> 绑定的原理，适用于低版本浏览器</p>
<p><code>instanceof</code> 运算符用于<strong>检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上</strong>，使用语法如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object <span class="keyword">instanceof</span> constructor</span><br></pre></td></tr></table></figure>

<p>可使用 <code>instanceof</code> 检测某个对象是不是另一个对象的实例，如 <code>new Person() instanceof Person --&gt; true</code></p>
<p>若为 <code>new</code> 调用，<code>this</code> 指向实例，<code>this instanceof 构造函数 --&gt; true</code>，普通调用的则返回 <code>false</code>。代码实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">firstName</span>) &#123;</span><br><span class="line">  <span class="comment">// this instanceof Person</span></span><br><span class="line">  <span class="comment">// 若返回 false 说明为普通调用</span></span><br><span class="line">  <span class="comment">// 返回类型错误信息--当前构造函数需要使用 new 调用</span></span><br><span class="line">  <span class="keyword">if</span> (!(<span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Person</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;当前构造函数需要使用 new 调用&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">firstName</span> = firstName;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当作普通函数调用时</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>(<span class="string">&quot;tn&quot;</span>)); <span class="comment">// Uncaught TypeError: 当前构造函数需要使用 new 调用</span></span><br></pre></td></tr></table></figure>

<p>由上可见，定义的 <code>Person</code> 构造函数已经无法被普通调用</p>
<p>但这种方案存在一点小瑕疵，可通过伪造实例的方法骗过构造函数里的判断。具体实现：<code>JS</code> 提供的 <code>apply/call</code> 方法可以修改 <code>this</code> 指向，若调用时将 <code>this</code> 指向修改为 <code>Person</code> 实例，就可成功骗过上面的语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>.<span class="title function_">call</span>(<span class="keyword">new</span> <span class="title class_">Person</span>(), <span class="string">&quot;tn&quot;</span>));  <span class="comment">// 输出 undefined</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>借助 <code>ES6</code> 提供的 <code>new.target</code> 属性，可与 <code>class</code> 配合定义抽象类</p>
<blockquote>
<p><code>《ECMAScript 6 入门》</code> 中提到：<code>ES6</code> 为 <code>new</code> 命令引入了一个 <code>new.target</code> 属性，该属性一般用在构造函数中，返回 <code>new</code> 命令作用于的那个构造函数，若构造函数不是通过 <code>new</code> 命令或 <code>Reflect.construct()</code> 调用的，<code>new.target</code> 会返回 <code>undefined</code>，因此该属性可以用来确定构造函数是怎么调用的</p>
</blockquote>
<p><code>new.target</code> 就是为确定构造函数的调用方式而生的，用法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;new: &quot;</span>, <span class="keyword">new</span> <span class="title class_">Person</span>()); <span class="comment">// new: Person &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 普通调用</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;not new: &quot;</span>, <span class="title class_">Person</span>()); <span class="comment">// not new: undefined</span></span><br></pre></td></tr></table></figure>

<p>可以使用 <code>new.target</code> 来非常简单的实现对构造函数和调用的限制：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="keyword">new</span>.<span class="property">target</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;当前构造函数需要使用 new 调用&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;not new: &quot;</span>, <span class="title class_">Person</span>()); <span class="comment">// Uncaught TypeError: 当前构造函数需要使用 new 调用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>面向对象编程使用 <code>ES6 Class</code>（最佳方案）</p>
<p><strong><code>ES6</code> 的 <code>Class</code> 限制构造函数只能被 <code>new</code> 调用</strong></p>
<p><code>ES6</code> 提供的 <code>Class</code> 作为构造函数的语法糖，实现语义化更好的面向对象编程，且对 <code>Class</code> 进行的规定：<strong>类的构造器必须使用 <code>new</code> 调用</strong>，因此后续在进行面向对象编程时，强烈推荐使用 <code>ES6</code> 的 <code>Class</code></p>
<blockquote>
<p><code>Class</code> 修复了很多 <code>ES5</code> 面向对象编程的缺陷，如<code>类中的所有方法都是不可枚举的</code>、<code>类的所有方法都无法被当作构造函数使用</code>等</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span>()); <span class="comment">// Uncaught TypeError: Class constructor Person cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="扩展：既然-Class-必须使用-new-来调用，那-new-target-属性的意义是什么？"><a href="#扩展：既然-Class-必须使用-new-来调用，那-new-target-属性的意义是什么？" class="headerlink" title="扩展：既然 Class 必须使用 new 来调用，那 new.target 属性的意义是什么？"></a>扩展：既然 <code>Class</code> 必须使用 <code>new</code> 来调用，那 <code>new.target</code> 属性的意义是什么？</h2><p><strong>答案：可以实现抽象类</strong></p>
<p><code>Class</code> 内部调用 <code>new.target</code>，会返回当前 <code>Class</code></p>
<p><code>《ECMAScript 6入门》</code>中也讲到：<strong>需要注意，子类继承父类时，<code>new.target</code> 会返回子类</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">type, name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = type;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// extends 是 Class 中实现继承的关键字</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;bao&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example4.2a57nolp15.webp" alt="example4"></p>
<p>通过上面例子可以发现，子类调用和父类调用的返回结果是不同的，<strong>利用这个特性就可以实现父类不可调用而子类可以调用的情况（面向对象中的抽象类）</strong></p>
<blockquote>
<p>什么是抽象类？</p>
<ul>
<li>以上面为例，定义了一个动物类 <code>Animal</code> 且通过这个类来创建动物</li>
<li>动物是个抽象的概念，当提到动物类时并不知道会创建什么动物，只有将动物实体化，如猫、狗，这才是具体的动物且每个动物的行为都会有所不同，因此不应通过创建 <code>Animal</code> 实例来生成动物</li>
<li><code>Animal</code> 只是动物抽象概念的集合，这里 <code>Animal</code> 就是一个抽象类，应该通过它的子类如 <code>Dog</code> 等来生成对应的 <code>dog</code> 实例</li>
</ul>
</blockquote>
<p><strong><code>new.target</code> 子类调用和父类调用的返回值是不同的，因此可以借助 <code>new.target</code> 实现抽象类</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">type, name, age</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Animal</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Abstract class cannot new&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">type</span> = type;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Animal</span>&#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;bao&quot;</span>, <span class="string">&quot;1&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog = <span class="keyword">new</span> <span class="title class_">Animal</span>(<span class="string">&quot;dog&quot;</span>, <span class="string">&quot;bao&quot;</span>, <span class="number">18</span>); <span class="comment">// Uncaught TypeError: Abstract class cannot new</span></span><br></pre></td></tr></table></figure>

<h1 id="函数对象和普通对象"><a href="#函数对象和普通对象" class="headerlink" title="函数对象和普通对象"></a>函数对象和普通对象</h1><p>经常看到一句话说：<code>万物皆对象</code>，对象就是属性的集合（对象里面的一切都是属性，只有属性没有方法，方法也是一种属性，因为它的属性表示为键值对的形式）</p>
<p>而在 <code>JavaScript</code> 中，创建对象有几种方式，如对象字面量 、通过构造函数 <code>new</code> 一个对象、<code>Object.create()</code></p>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example3.7p3q4sjk0k.webp" alt="example3"></p>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example4.2obnd8cpi0.webp" alt="example4"></p>
<p>暂且先不管上面的代码有什么意义，至少能看出都是对象且却存在着差异性</p>
<p><strong>在 <code>JavaScript</code> 中可以将对象分为<code>函数对象</code>和<code>普通对象</code></strong></p>
<ul>
<li>函数对象就是 <code>JavaScript</code> 中用函数来模拟的类实现，如 <code>Object</code>、<code>Function</code> 就是典型的函数对象</li>
</ul>
<p>下述代码中 <code>obj1</code>、<code>obj2</code>、<code>obj3</code>、<code>obj4</code> 都是普通对象，<code>fun1</code>、<code>fun2</code>、<code>fun3</code> 都是 <code>Function</code> 的实例，即函数对象</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fun1</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> fun2 = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> fun3 = <span class="keyword">new</span> <span class="title class_">Function</span>(<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;console.log(name)&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">const</span> obj3 = <span class="keyword">new</span> <span class="title function_">fun1</span>();</span><br><span class="line"><span class="keyword">const</span> obj4 = <span class="keyword">new</span> <span class="keyword">new</span> <span class="title class_">Function</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Object</span>); <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="title class_">Function</span>); <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> fun1); <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> fun2); <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> fun3); <span class="comment">// function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj1); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj2); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj3); <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> obj4); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>因此，<strong>所有 <code>Function</code> 的实例都是函数对象，其他均为普通对象，其中包括 <code>Function</code> 实例的实例</strong></p>
<blockquote>
<p><code>JavaScript</code> 中万物皆对象，而对象皆出自构造（构造函数） </p>
<ul>
<li>我的理解是所有对象都是由 <code>new</code> 操作符后跟函数调用来创建的</li>
<li>字面量表示法只是语法糖（即本质也是 <code>new</code>，功能不变、使用更简洁），无论是 <code>function Foo()</code> 还是 <code>let a = &#123; b : 1 &#125;</code></li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="comment">// function 就是个语法糖</span></span><br><span class="line"><span class="comment">// 内部等同于 new Function()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a = &#123; <span class="attr">b</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="comment">// 这个字面量内部也是使用了 new Object()</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于创建一个对象来说，<strong>更推荐使用<code>字面量</code>的方式创建</strong>，因为使用 <code>new Object()</code> 的方式创建对象需通过作用域链一层层找到 <code>Object</code>，但使用字面量的方式就没这个问题</p>
</blockquote>
<p><strong><code>Number</code>、<code>String</code>、<code>Boolean</code>、<code>Array</code>、<code>Object</code>、<code>Function</code>、<code>Date</code>、<code>RegExp</code>、<code>Error</code> 等都是函数，而且是内置的原生构造函数，在运行时会自动出现在执行环境中</strong></p>
<p><strong>构造函数是为了创建特定类型的对象，这些通过同一构造函数创建的对象有相同原型，共享某些方法</strong>。如：所有的数组都可以调用 <code>push</code> 方法，因为它们有相同原型</p>
<blockquote>
<p><code>原型</code>和<code>原型链</code>都是来源于对象而服务于对象的概念</p>
</blockquote>
<h1 id="原型（prototype）"><a href="#原型（prototype）" class="headerlink" title="原型（prototype）"></a>原型（prototype）</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><code>JavaScript</code> 常被描述为一种基于原型的语言 (<code>prototype-based language</code>)，这个和 <code>Java</code> 等基于类的语言不一样</p>
<blockquote>
<p>原型是 <code>JavaScript</code> 语言面向对象系统的根本</p>
<p>类是对一类实体的结构、行为的抽象。在基于类的面向对象语言中，首先关注的是抽象 —— 需要先把具备通用性的类给设计出来，才能用这个类去实例化一个对象，进而关注到具体层面的东西</p>
<p>而在 <code>JS</code> 这样的原型语言中，首先需要关注的就是具体 —— 具体的每一个实例的行为。根据不同实例的行为特性，把相似的实例关联到一个原型对象里去。在这个被关联的原型对象里，就囊括了那些较为通用的行为和属性。基于此原型的实例，都能 “复制” 它的能力</p>
<p>在原型编程范式中，正是通过复制来创建新对象。但这个“复制”未必一定要开辟新的内存、把原型对象照着再实现一遍 —— 复制的是能力，而不必是实体。如在 <code>JS</code> 中就是通过使新对象保持对原型对象的引用来做到了 “复制”</p>
</blockquote>
<p>每个对象拥有一个原型对象，对象以其原型为模板，从原型继承方法和属性，这些属性和方法定义在对象的构造器函数的 <code>prototype</code> 属性上，而非对象实例本身</p>
<blockquote>
<p>prototype - object that provides shared properties for other objects</p>
</blockquote>
<p>在规范里 <code>prototype</code> 被定义为：<strong>给其它对象实例提供共享属性的对象</strong>。因此 <code>prototype</code> 自己本身也是对象，只是被用以承担某个职能罢了</p>
<blockquote>
<blockquote>
<p><strong>只有<code>函数</code>才拥有该属性，它是 <code>function 对象</code> 的一个<code>显式原型属性</code>，当声明一个函数时该属性就被自动创建了，它定义了构造函数制造出来的对象实例的公共祖先，通过该构造函数产生的对象可以继承该原型上的属性和方法</strong></p>
</blockquote>
</blockquote>
<p>基本上所有函数都有这个属性，但也有例外。若用以下方法创建一个函数，可发现这个函数是不具有 <code>prototype</code> 属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">bind</span>();</span><br></pre></td></tr></table></figure>

<p>因为 <code>Function.prototype</code> 是引擎创建出来的函数对象，引擎认为不需给这个对象添加 <code>prototype</code> 属性，<code>Function.prototype.bind</code> 也是一样</p>
<p>在 <code>prototype</code> 上添加属性和方法，每个构造出来的对象实例都可继承这些属性和方法。虽然每个对象都是独立的，但它们都有共同的祖先，当访问这个对象的属性时，若对象本身没有该属性则会往上找到它的原型，然后在原型上访问这个属性</p>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p><strong><code>prototype</code> 有个默认属性 <code>constructor</code>，指向一个函数，这个函数就是该对象的构造函数</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Person</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>constructor</code> 是个公有且不可枚举属性，一旦改变了函数的 <code>prototype</code>，那新对象就没有这个属性（可通过原型链取到 <code>constructor</code>）</p>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example5.7egwcylm9j.webp" alt="example5"></p>
<p><strong>注意，每个对象都有其对应的构造函数，本身或继承而来</strong></p>
<ul>
<li>单从 <code>constructor</code> 这个属性来讲只有 <code>prototype</code> 对象才有</li>
<li>每个函数在创建时 <code>JavaScript</code> 会同时创建一个该函数对应的 <code>prototype</code> 对象</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数创建的对象.<span class="property">__proto__</span> === 该函数.<span class="property"><span class="keyword">prototype</span></span></span><br><span class="line"></span><br><span class="line">函数.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === 该函数本身</span><br></pre></td></tr></table></figure>

<p>故通过函数创建的对象即使自己没有 <code>constructor</code> 属性，它也能通过 <code>__proto__</code> 找到对应的 <code>constructor</code>，所以任何对象最终都可以找到其对应的构造函数</p>
<blockquote>
<p>其实这个属性可以说是一个历史遗留问题，它有两个作用：</p>
<ul>
<li>让实例对象知道是什么函数构造了它</li>
<li>若想给某些类库中的构造函数增加一些自定义的方法，就可以通过 <code>xx.constructor.method</code> 来扩展</li>
</ul>
</blockquote>
<h2 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h2><blockquote>
<ul>
<li>首先需要明确：<code>__proto__</code> 和 <code>constructor</code> 是对象独有的；<code>prototype</code> 是函数独有的  </li>
<li>但在 <code>JavaScript</code> 中，函数也是对象，因此函数也拥有 <code>__proto__</code> 和 <code>constructor</code> 属性</li>
</ul>
</blockquote>
<p><strong>每个对象都有该隐式原型属性，指向了原型（若是构造函数创建的对象，则指向创建该对象的构造函数的原型）</strong> </p>
<p><strong>这里用 <code>__proto__</code> 获取对象的原型，<code>__proto__</code> 是每个对象实例上都有的属性，<code>prototype</code>是构造函数的属性，这两个并不一样，但 <code>__proto__</code> 和 <code>prototype</code> 指向同一个对象</strong></p>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example6.1sf5z3kbg2.webp" alt="example6"></p>
<p><code>__proto__</code> 指向了 <code>[[prototype]]</code>（一个对象或 <code>null</code>），因 <code>[[prototype]]</code> 是内部属性，并不能从外部访问到，因此有些浏览器实现了 <code>__proto__</code> 来访问</p>
<p>因此，<code>ECMAScript</code> 规范说 <code>prototype</code> 应当是一个隐式引用：</p>
<ul>
<li><p>部分浏览器实现了 <code>__proto__</code> ，使得可以通过 <code>obj.__proto__</code> 直接访问原型，通过 <code>obj.__proto__ = anotherObj</code> 直接设置原型<br>；<code>ES6</code> 规范只好向事实低头，将 <code>__proto__</code> 属性纳入了规范的一部分，以确保 <code>Web</code> 浏览器的兼容性，但不推荐使用</p>
</li>
<li><p>除了标准化的原因之外还有性能问题，为了更好的支持，推荐使用 <code>Object.getPrototypeOf()</code> 访问指定对象的 <code>prototype</code> 对象</p>
</li>
<li><p>通过 <code>Object.setPrototypeOf(obj, anotherObj)</code> 设置指定对象的 <code>prototype</code> 对象</p>
</li>
<li><p><strong><code>__proto__</code> 属性既不能被 <code>for...in</code> 遍历出来，也不能被 <code>Object.keys(obj)</code> 查找出来</strong></p>
</li>
</ul>
<p>其实 <code>__proto__</code> 是个定义在 <code>Object.prototype</code> 上的<code>访问器属性</code>（即用 <code>getter</code> 和 <code>setter</code> 定义的属性），访问对象的 <code>obj.__proto__</code> 属性，<strong>默认走的是 <code>Object.prototype</code> 对象上 <code>__proto__</code> 属性的 <code>get/set</code> 方法</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&#x27;__proto__&#x27;</span>, &#123; </span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123; </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;get&#x27;</span>);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;); </span><br><span class="line">(&#123;&#125;).<span class="property">__proto__</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="keyword">new</span> <span class="title class_">Object</span>()).<span class="property">__proto__</span>); </span><br><span class="line"><span class="comment">// get </span></span><br><span class="line"><span class="comment">// get</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> weakMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span> = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">__proto__</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>[<span class="string">&#x27;[[prototype]]&#x27;</span>] === <span class="literal">null</span> ? weakMap.<span class="title function_">get</span>(<span class="variable language_">this</span>) : <span class="variable language_">this</span>[<span class="string">&#x27;[[prototype]]&#x27;</span>];</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">__proto__</span>(<span class="params">newPrototype</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(newPrototype)) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">`<span class="subst">$&#123;newPrototype&#125;</span> is not extensible`</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> isObject = <span class="keyword">typeof</span> newPrototype === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> newPrototype === <span class="string">&#x27;function&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (newPrototype === <span class="literal">null</span> || isObject) &#123;</span><br><span class="line">      <span class="comment">// 若之前通过 __proto__ 设置成 null</span></span><br><span class="line">      <span class="comment">// 此时再通过给 __proto__ 赋值的方式修改原型都是徒劳</span></span><br><span class="line">      <span class="comment">// 表现就是 obj.__proto__ = &#123; a: 1 &#125; 就像一个普通属性 obj.xxx = &#123; a: 1 &#125;</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable language_">this</span>[<span class="string">&#x27;[[prototype]]&#x27;</span>] === <span class="literal">null</span>) &#123;</span><br><span class="line">        weakMap.<span class="title function_">set</span>(<span class="variable language_">this</span>, newPrototype);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>[<span class="string">&#x27;[[prototype]]&#x27;</span>] = newPrototype;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ... 其它属性如 toString，hasOwnProperty 等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>若一个对象的 <code>__proto__</code> 属性被赋值为 <code>null</code>，这时它的原型确实已经被修改为 <code>null</code>，但想再通过对 <code>__proto__</code> 赋值的方式设置原型时是无效的，这时 <code>__proto__</code> 和一个普通属性没有区别，<strong>只能通过 <code>Reflect.setPrototypeOf()</code> 或 <code>Object.setPrototypeOf()</code> 才能修改原型</strong></p>
<blockquote>
<p><code>Reflect.setPrototypeOf()</code> 之所以能修改原型是因为它是直接修改对象的原型属性，即内部直接对对象的 <code>[[prototype]]</code> 属性赋值，而不会通过 <code>__proto__</code> 的 <code>getter</code></p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;xiaoming&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(obj)); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次赋值为 null</span></span><br><span class="line">obj.<span class="property">__proto__</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">__proto__</span> = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>); <span class="comment">// &#123; a: 1 &#125;</span></span><br><span class="line"><span class="comment">// __proto__ 就像一个普通属性一样 obj.xxx = &#123; a: 1 &#125;</span></span><br><span class="line"><span class="comment">// 并没有将原型设置成功</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(obj)); <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>(obj, &#123; <span class="attr">b</span>: <span class="number">2</span> &#125;);</span><br><span class="line"><span class="comment">// __proto__ 被设置为 null 后，obj 的 __proto__ 属性和一个普通的属性没有区别</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>); <span class="comment">// &#123; a: 1 &#125;</span></span><br><span class="line"><span class="comment">// 使用 Reflect.setPrototypeOf 是可以设置原型的</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>(obj)); <span class="comment">// &#123; b: 2 &#125;</span></span><br></pre></td></tr></table></figure>

<p>通过改变一个对象的 <code>[[Prototype]]</code> 属性来改变和继承属性会对性能造成非常严重的影响且性能消耗的时间也不是简单的花费在 <code>obj.__proto__ = ...</code> 语句上，它还会影响到所有继承自该 <code>[[Prototype]]</code> 的对象，若关心性能就不应该修改一个对象的 <code>[[Prototype]]</code></p>
<p>若要读取或修改对象的 <code>[[Prototype]]</code> 属性，建议使用如下方案，但此时设置对象的 <code>[[Prototype]]</code> 依旧是一个缓慢的操作，还是那句话：若性能是一个考虑问题，就要避免这种操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>();</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">getPrototypeOf</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>();</span><br><span class="line"><span class="title class_">Reflect</span>.<span class="title function_">setPrototypeOf</span>();</span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li><strong><code>__proto__</code> 存在于所有的对象上，是对象所独有的且指向它的原型对象</strong></li>
<li>它的作用：<strong>当在访问一个对象属性时，若该对象内部不存在这个属性，则会去它的 <code>__proto__</code> 属性所指向的对象（原型对象，原型也是对象也有它自己的原型）上查找，若原型对象不存在这个属性，则去其原型对象的 <code>__proto__</code> 属性所指向的原型对象上去查找... 以此类推，直到找到 <code>null</code>，返回 <code>undefined</code></strong></li>
<li>这个查找的过程也就构成了常说的 <code>原型链</code></li>
</ul>
<blockquote>
<p>因为在 <code>JS</code> 中是没有类的概念的，为了实现类似继承的方式，通过 <code>__proto__</code> 将对象和原型联系起来组成<code>原型链</code>，得以让对象可以访问到不属于自己的属性</p>
</blockquote>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example7.m7470yjq.webp" alt="example7"></p>
<h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p>之前说对象的创建方式主要有两种，一种是 <code>new</code> 操作符后跟函数调用，另一种是字面量表示法</p>
<p>第三种就是 <code>ES5</code> 提供的 <code>Object.create()</code> 方法，该方法会创建一个新对象，第一个参数接收一个对象，将会作为与新创建对象关联的原型对象，第二个可选参数是属性描述符（不常用，默认是 <code>undefined</code>）</p>
<blockquote>
<p>平常所看到的空对象其实并不是严格意义上的空对象，它的原型对象指向<code>Object.prototype</code>，还可以继承 <code>hasOwnProperty</code>、<code>toString</code>、<code>valueOf</code> 等方法</p>
</blockquote>
<ul>
<li>若要创建一个新对象同时继承另一个对象的 <code>[[Prototype]] </code>，推荐使用 <code>Object.create()</code></li>
<li>若想生成一个不继承任何属性的对象，可使用 <code>Object.create(null)</code></li>
<li>若想生成一个平常字面量方法生成的对象，需要将其原型对象指向 <code>Object.prototype</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj= <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="literal">null</span>);</span><br><span class="line">obj.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// false;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p><strong>模拟实现 <code>Object.create</code></strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简易版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params">proto</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> F = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = proto;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完整版</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params">proto, propertyObject = <span class="literal">undefined</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">&#x27;function&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Object prototype may only be an Object or null.&#x27;</span>);</span><br><span class="line">  <span class="keyword">if</span> (propertyObject == <span class="literal">null</span>) <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;Cannot convert undefined or null to object&#x27;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = proto;</span><br><span class="line">  <span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(propertyObject != <span class="literal">undefined</span>) <span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, propertyObject);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建一个没有原型对象的对象，Object.create(null)  </span></span><br><span class="line">  <span class="keyword">if</span>(proto === <span class="literal">null</span>) obj.<span class="property">__proto__</span> = <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><p>当在一个对象 <code>obj</code> 上访问某个属性时：</p>
<ul>
<li>若该属性不存在于该 <code>obj</code> 上，则会通过 <code>__proto__</code> 去对象的原型即 <code>obj.__proto__</code> 上去找这个属性</li>
<li>若有则返回该属性，没有则继续去对象 <code>obj</code> 的原型的原型即 <code>obj.__proto__.__proto__</code> 去找，依此类推... </li>
<li>一直访问到 <code>纯对象的原型</code> 即 <code>Object.prototype</code>，没有的话则继续往上找即 <code>Object.prototype.__proto__</code>，即 <code>null</code>，此时直接返回 <code>undefined</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span> <span class="title class_">Object</span>().<span class="property">__proto__</span>.<span class="property">__proto__</span>); <span class="comment">// null</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">__proto__</span> === <span class="literal">null</span>; <span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p>这就可以得到原型链之所以叫原型链而不叫原型环，说明它是有始有终的，原型链的顶层就是 <code>null</code>，返回 <code>undefined</code>，所以原型链不会无限的找下去</p>
<p><strong>因此原型链可以描述为由对象的 <code>__proto__</code> 属性将对象和原型联系起来直到 <code>Object.prototype.__proto__</code> 为 <code>null</code> 的链就是原型链</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, grade</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">grade</span> = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stu = <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stu.<span class="property">gender</span>); <span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></figure>

<p>访问 <code>stu.gender</code> 的整个过程如下图：</p>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example8.70agm3dbdh.webp" alt="example8"></p>
<p>而函数 <code>Student</code> 的原型链应该是这样的：</p>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example9.102ahd3por.webp" alt="example9"></p>
<p>上文介绍了 <code>prototype</code> 和 <code>__proto__</code> 的区别，其中原型对象 <code>prototype</code> 是构造函数的属性，<code>__proto__</code> 是每个实例对象上都有的属性，这两个并不一样，但指向同个对象，如上面例子 <code>stu.__proto__</code> 和 <code>Student.prototype</code> 指向同个对象</p>
<p>那原型链的构建是依赖于 <code>prototype</code> 还是 <code>__proto__</code> 呢？</p>
<ul>
<li>上图中，<code>Student.prototype</code> 中的 <code>prototype</code> 并没有构建成一条原型链，其只是指向原型链中的某一处</li>
<li><strong>原型链的构建依赖于 <code>__proto__</code></strong>，如上图通过 <code>stu.__proto__</code> 指向 <code>Student.prototype</code>，<code>stu.__proto__.__proto__</code> 指向 <code>Object.prototyp</code>，如此一层一层最终链接到 <code>null</code></li>
</ul>
<blockquote>
<p>可以这么理解：<code>Student</code> 是一个 <code>constructor</code> 也是一个 <code>function</code>，它身上有着 <code>prototype</code> 的 <code>reference</code>，只要调用 <code>stu = new Student()</code> 就会将 <code>stu.__proto__</code> 指向到 <code>Student</code> 的 <code>prototype</code> 对象</p>
</blockquote>
<p>不要使用类似 <code>Bar.prototype = Foo</code>，因为这不会执行 <code>Foo</code> 的原型，而是指向函数 <code>Foo</code>。因此原型链将会回溯到 <code>Function.prototype</code> 而不是 <code>Foo.prototype</code>，因此 <code>Foo</code> 原型上的方法将不会在 <code>Bar</code> 的原型链上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;method&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Bar</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Foo</span>; <span class="comment">// Bar.prototype 指向到函数 Foo</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="keyword">new</span> <span class="title class_">Bar</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">dir</span>(bar);</span><br><span class="line">bar.<span class="title function_">method</span>(); <span class="comment">// bar.getMethod is not a function</span></span><br><span class="line"></span><br><span class="line">bar.<span class="property">__proto__</span> === <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h2 id="原型链上属性的增删改查"><a href="#原型链上属性的增删改查" class="headerlink" title="原型链上属性的增删改查"></a>原型链上属性的增删改查</h2><p>通过一个对象改变了原型上的引用值类型的属性，则所有对象实例的这个属性值都会随之更改</p>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example10.45t1wu18m.webp" alt="example10"></p>
<p>依据当自身没有这个属性时就会向上往原型查询的说法，再次删除这个属性是不是就可以删除原型上的属性了？事实并没有，由此可见<strong>对象实例并不能删除原型上的属性</strong></p>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example11.5fkpmmg3wh.webp" alt="example11"></p>
<p><strong>谁调用这个方法，这个方法中的 <code>this</code> 就指向这个调用它的对象</strong></p>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example12.8vn1eppqyl.webp" alt="example12"></p>
<h1 id="instanceof-操作符"><a href="#instanceof-操作符" class="headerlink" title="instanceof 操作符"></a>instanceof 操作符</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><p>上面说过平常判断一个变量的类型经常会使用 <code>typeof</code> 运算符，但对于引用类型来说并不能很好区分（除了函数对象会返回 <code>function</code> 外其他都返回 <code>object</code>）</p>
<blockquote>
<p><code>MDN</code> 对于 <code>instanceof</code> 运算符的描述：</p>
<ul>
<li><code>instanceof</code> 运算符用于测试构造函数的 <code>prototype</code> 属性是否出现在对象实例的原型链中的任何位置</li>
</ul>
</blockquote>
<p><code>instanceof</code> 和 <code>typeof</code> 非常的类似：<code>instanceof</code> 用于判断对象是否是某个构造函数的实例，若 <code>obj instanceof A</code>，就说明 <code>obj</code> 是 <code>A</code> 的实例</p>
<blockquote>
<p><strong>它的原理一句话概括就是：<code>obj instanceof 构造器 A</code> 等同于判断 <code>A</code> 的 <code>prototype</code> 是不是 <code>obj</code> 的原型</strong></p>
</blockquote>
<ul>
<li><code>instanceof</code> 操作符左边是一个对象，右边是一个构造函数，在左边对象的原型链上查找（通过 <code>__proto__</code>）直到找到右边构造函数的 <code>prototype</code> 属性就返回 <code>true</code></li>
<li>或查找到顶层 <code>null</code>（<code>Object.prototype.__proto__</code>），就返回 <code>false</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>)&#123;&#125; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">D</span>(<span class="params"></span>)&#123;&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> o1 = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line">o1 <span class="keyword">instanceof</span> C; <span class="comment">// true，因为 Object.getPrototypeOf(o1) === C.prototype</span></span><br><span class="line"></span><br><span class="line">o1 <span class="keyword">instanceof</span> D; <span class="comment">// false，因为 D.prototype 不在 o1 的原型链上</span></span><br><span class="line"></span><br><span class="line">o1 <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true，因为 Object.prototype.isPrototypeOf(o1) 返回 true</span></span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true，同上</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 C.prototype</span></span><br><span class="line">C.<span class="property"><span class="keyword">prototype</span></span> = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> o2 = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br><span class="line"></span><br><span class="line">o2 <span class="keyword">instanceof</span> C; <span class="comment">// true</span></span><br><span class="line">o1 <span class="keyword">instanceof</span> C; <span class="comment">// false，C.prototype 指向了一个空对象，这个空对象不在 o1 的原型链上</span></span><br><span class="line"></span><br><span class="line">D.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">C</span>(); <span class="comment">// 继承</span></span><br><span class="line"><span class="keyword">const</span> o3 = <span class="keyword">new</span> <span class="title function_">D</span>();</span><br><span class="line">o3 <span class="keyword">instanceof</span> D; <span class="comment">// true</span></span><br><span class="line">o3 <span class="keyword">instanceof</span> C; <span class="comment">// true 因为 C.prototype 现在在 o3 的原型链上</span></span><br></pre></td></tr></table></figure>

<p><strong>与 <code>typeof</code> 方法不同的是：<code>instanceof</code> 方法要求开发者明确地确认对象为某特定类型</strong></p>
<h2 id="模拟实现"><a href="#模拟实现" class="headerlink" title="模拟实现"></a>模拟实现</h2><p>简单模拟实现</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种：递归查找原型链</span></span><br><span class="line"><span class="comment">// 参数 obj 表示 instanceof 左边的对象 </span></span><br><span class="line"><span class="comment">// 参数 Constructor 表示 instanceof 右边的构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceOf</span>(<span class="params">obj, Constructor</span>) &#123;</span><br><span class="line">  <span class="comment">// 取构造函数显示原型 </span></span><br><span class="line">  <span class="keyword">let</span> rightP = <span class="title class_">Constructor</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="comment">// 取对象隐式原型 </span></span><br><span class="line">  <span class="keyword">let</span> leftP = obj.<span class="property">__proto__</span>;</span><br><span class="line">  <span class="comment">// 到达原型链顶层还未找到则返回 false </span></span><br><span class="line">  <span class="keyword">if</span> (leftP === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对象实例的隐式原型等于构造函数显示原型则返回 true </span></span><br><span class="line">  <span class="keyword">if</span> (leftP === rightP) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 递归查找原型链上一层 </span></span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">myInstanceOf</span>(obj.<span class="property">__proto__</span>, <span class="title class_">Constructor</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种：迭代</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">left, right</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = right.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  left = left.<span class="property">__proto__</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left === <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (prototype === left) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    left = left.<span class="property">__proto__</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在就可以解释一些比较令人费解的结果了</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [];</span><br><span class="line">fn <span class="keyword">instanceof</span> <span class="title class_">Function</span>; <span class="comment">// true</span></span><br><span class="line">fn <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 1. fn.__proto__ === Function.prototype;</span></span><br><span class="line"><span class="comment">// 2. fn.__proto__.__proto__ === Function.prototype.__proto__ === Object.prototype;</span></span><br><span class="line"></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Array</span>; <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 1. arr.__proto__ === Array.prototype;</span></span><br><span class="line"><span class="comment">// 2. arr.__proto__.__proto__ === Array.prototype.__proto__ === Object.prototype;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 1. Object.__proto__ === Function.prototype;</span></span><br><span class="line"><span class="comment">// 2. Object.__proto__.__proto__ === Function.prototype.__proto__ === Object.prototype;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 1. Function.__proto__ === Function.prototype;</span></span><br><span class="line"><span class="comment">// 2. Function.__proto__.__proto__ === Object.prototype;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>; <span class="comment">// true </span></span><br><span class="line"><span class="title class_">Foo</span> <span class="keyword">instanceof</span> <span class="title class_">Foo</span>; <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 1. Foo.__proto__ === Function.prototype;</span></span><br><span class="line"><span class="comment">// 2. Foo.__proto__.__proto__ === Function.prototype.__proto__ = Object.prototype;</span></span><br><span class="line"><span class="comment">// 3. Foo.__proto__.__proto__.__proto__ === Object.prototype.__proto__ = null;</span></span><br><span class="line"><span class="comment">// 4. null</span></span><br></pre></td></tr></table></figure>

<p><strong>总结：<code>instanceof</code> 运算符用于检查右边构造函数的 <code>prototype</code> 属性是否出现在左边对象的原型链中的任何位置，其实它表示的是一种原型链继承的关系</strong></p>
<h1 id="Object-Function"><a href="#Object-Function" class="headerlink" title="Object &amp; Function"></a>Object &amp; Function</h1><p>上面提到的 <code>Object.__proto__ === Function.prototype</code> 和 <code>Function.__proto__ === Function.prototype</code> 到底是为什么呢？</p>
<h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h2><blockquote>
<p><code>ECMAScript</code> 上的定义：</p>
<p>The value of the [[Prototype]] internal property of the Object prototype object is null, the value of the [[Class]] internal property is &quot;Object&quot;, and the initial value of the [[Extensible]] internal property is true</p>
</blockquote>
<p><code>Object.prototype</code> 表示 <code>Object</code> 的原型对象，其 <code>[[Prototype]]</code> 属性是 <code>null</code>，访问器属性 <code>__proto__</code> 暴露了一个对象的内部 <code>[[Prototype]]</code></p>
<p><code>Object.prototype</code> 并不是通过 <code>Object</code> 函数创建的，为什么呢？看如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">value</span> = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line">foo.<span class="property">__proto__</span> === <span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>实例对象的 <code>__proto__</code> 指向构造函数的 <code>prototype</code>，即 <code>foo.__proto__</code> 指向 <code>Foo.prototype</code>，但 <strong><code>Object.prototype.__proto__</code> 是 <code>null</code>，所以 <code>Object.prototype</code> 并不是通过 <code>Object</code> 函数创建的</strong> --&gt; <strong>其实 <code>Object.prototype</code> 是引擎根据 <code>ECMAScript</code> 规范创造的一个对象</strong></p>
<blockquote>
<p>所以可以说：<code>所有实例都是对象，但是对象不一定都是实例</code></p>
</blockquote>
<p>不考虑 <code>null</code> 的情况下，<code>Object.prototype</code> 就是原型链的顶端，所有对象实例都可以继承它的 <code>toString</code> 等方法和属性</p>
<h2 id="Function-prototype"><a href="#Function-prototype" class="headerlink" title="Function.prototype"></a>Function.prototype</h2><blockquote>
<p><code>ECMAScript</code> 上的定义：</p>
<ul>
<li><p>The Function prototype object is itself a Function object (its [[Class]] is &quot;Function&quot;).</p>
</li>
<li><p>The value of the [[Prototype]] internal property of the Function prototype object is the standard built-in Object prototype object.</p>
</li>
<li><p>The Function prototype object does not have a valueOf property of its own; however, it inherits the valueOf property from the Object prototype Object</p>
</li>
</ul>
</blockquote>
<p><strong>从定义中可知道：<code>Function.prototype</code> 对象是一个函数（对象），其 <code>[[Prototype]]</code> 内部属性值指向内建对象 <code>Object.prototype</code>。<code>Function.prototype</code> 对象自身没有 <code>valueOf</code> 属性，其从 <code>Object.prototype</code> 对象继承了 <code>valueOf</code> 属性</strong></p>
<p><code>Function.prototype</code> 的 <code>[[Class]]</code> 属性是 <code>Function</code>，所以这是一个函数，但又不大一样，因为<strong>只有函数才有 <code>prototype</code> 属性，但并不是所有函数都有这个属性，因为 <code>Function.prototype</code> 这个函数就没有</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// ƒ () &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>下面这个函数也没有 <code>prototype</code> 属性</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">bind</span>(); <span class="comment">// ƒ () &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line">fun.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>为什么没有呢？我的理解是 <code>Function.prototype</code> 是引擎创建出来的函数，引擎认为不需要给这个函数对象添加 <code>prototype</code> 属性，不然 <code>Function.prototype.prototype…</code> 将无休无止并且没有存在的意义</p>
<p><strong><code>Function.prototype</code> 不可写、不可配置、不可遍历，即它永远指向固定的一个对象且是其他所有函数的原型对象，所有函数本身的 <code>__proto__</code> 指向它</strong></p>
<blockquote>
<p>引擎首先创建了 <code>Object.prototype</code> ，然后创建了 <code>Function.prototype</code> 且通过 <code>__proto__</code> 将两者联系了起来</p>
</blockquote>
<h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><p><code>JS</code> 中 <code>Obejct</code> 和 <code>Function</code> 均是构造函数（构造函数也是函数），和 <code>object</code>、<code>function</code> 不是一个东西，分别用于创建 <code>对象</code> 与 <code>函数</code> 实例</p>
<blockquote>
<p><code>ECMAScript</code> 上的定义：The value of the [[Prototype]] internal property of the Object constructor is the standard built-in Function prototype object</p>
</blockquote>
<p><code>Object</code> 作为构造函数时，其 <code>[[Prototype]]</code> 内部属性值指向 <code>Function.prototype</code>，即：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Object</code> 的全貌是：<code>function Object() &#123;&#125;</code>，它是普通对象的构造函数，当 <code>var foo = &#123;&#125;</code> 时相当于实例化 <code>Object</code>，即 <code>new Object()</code></p>
<p>使用 <code>new Object()</code> 创建新对象时，这个新对象的 <code>[[Prototype]]</code> 内部属性指向构造函数的 <code>prototype</code> 属性，对应就是 <code>Object.prototype</code></p>
<p>当然也可以通过对象字面量等方式创建对象：</p>
<ul>
<li>使用对象字面量创建的对象，其 <code>[[Prototype]]</code> 值是 <code>Object.prototype</code></li>
<li>使用数组字面量创建的对象，其 <code>[[Prototype]]</code> 值是 <code>Array.prototype</code></li>
<li>使用 <code>function f()&#123;&#125;</code> 函数创建的对象，其 <code>[[Prototype]]</code> 值是 <code>Function.prototype</code></li>
<li>使用 <code>new fun()</code> 创建的对象，其中 <code>fun</code> 是由 <code>JS</code> 提供的内建构造器函数之一（<code>Object</code>、<code>Function</code>、<code>Array</code>、<code>Boolean</code>、<code>Date</code>、<code>Number</code>、<code>String</code> 等），其 <code>[[Prototype]]</code> 值是 <code>fun.prototype</code></li>
<li>使用其他 <code>JS</code> 构造器函数创建的对象，其 <code>[[Prototype]]</code> 值就是该构造器函数的 <code>prototype</code> 属性</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原型链：o.__proto__ -&gt; Object.prototype -&gt; null</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链：a -&gt; Array.prototype -&gt; Object.prototype -&gt; null</span></span><br><span class="line"><span class="keyword">let</span> a = [<span class="string">&quot;yo&quot;</span>, <span class="string">&quot;whadup&quot;</span>, <span class="string">&quot;?&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链：f -&gt; Function.prototype -&gt; Object.prototype -&gt; null</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链：fun -&gt; Function.prototype -&gt; Object.prototype -&gt; null</span></span><br><span class="line"><span class="keyword">let</span> fun = <span class="keyword">new</span> <span class="title class_">Function</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链：foo -&gt; Foo.prototype -&gt; Object.prototype -&gt; null</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原型链：foo -&gt; Object.prototype -&gt; null</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br></pre></td></tr></table></figure>

<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><blockquote>
<p><code>ECMAScript</code> 上的定义：The Function constructor is itself a Function object and its [[Class]] is &quot;Function&quot;. The value of the [[Prototype]] internal property of the Function constructor is the standard built-in Function prototype object</p>
</blockquote>
<p><code>Function</code> 构造函数是一个函数对象，其 <code>[[Class]]</code> 属性是 <code>Function</code>。<code>Function</code> 的 <code>[[Prototype]]</code> 属性指向了 <code>Function.prototype</code>，即：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Function</code> 的全貌是：<code>function Function() &#123;&#125;</code>，它是函数对象的构造函数，当 <code>function foo() &#123;&#125;</code> 时相当于实例化 <code>Function</code>，即 <code>new Function()</code></p>
<p>我们知道函数的本质是通过 <code>new Function()</code> 生成的，但<code>Function.prototype</code> 是引擎自己创建的，所以又可以得出一个结论</p>
<blockquote>
<p>不是所有函数都是 <code>new Function()</code> 产生的</p>
</blockquote>
<h2 id="Function-Object-鸡蛋问题"><a href="#Function-Object-鸡蛋问题" class="headerlink" title="Function &amp; Object 鸡蛋问题"></a>Function &amp; Object 鸡蛋问题</h2><p>先看下面代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span> <span class="keyword">instanceof</span> <span class="title class_">Object</span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="property">__proto__</span>.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Function</span> <span class="keyword">instanceof</span> <span class="title class_">Function</span>; <span class="comment">// true</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property">__proto__</span> === <span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Object</code> 构造函数继承了 <code>Function.prototype</code>，一切<code>函数对象</code>都直接继承自 <code>Function</code> 对象（系统内置的构造函数），<code>函数对象</code> 包括了 <code>Function</code>、<code>Object</code>、<code>Array</code>、<code>String</code>、<code>Number</code>、<code>RegExp</code>、<code>Date</code> 等，<code>Function</code> 其实不仅用于构造函数，它也充当了 <code>函数对象</code> 的构造器</p>
<p>同时 <code>Function</code> 构造函数继承了 <code>Object.prototype</code>，这里就产生了 <code>鸡和蛋</code> 的问题。因为 <code>Function.prototype</code> 和 <code>Function.__proto__</code> 都指向 <code>Function.prototype</code></p>
<p>对于 <code>Function.__proto__ === Function.prototype</code> 这一现象有 <code>2</code> 种解释，争论点在于 <code>Function</code> 对象是不是由 <code>Function</code> 构造函数创建的一个实例？</p>
<ul>
<li><p><code>YES</code>：按照 <code>JavaScript</code> 中实例的定义，<code>a</code> 是 <code>b</code> 的实例即 <code>a instanceof b</code> 为 <code>true</code>，默认判断条件就是 <code>b.prototype</code> 在 <code>a</code> 的原型链上。而 <code>Function instanceof Function</code> 为 <code>true</code>，本质上即 <code>Object.getPrototypeOf(Function) === Function.prototype</code>，正符合此定义</p>
</li>
<li><p><code>NO</code>：<code>Function</code> 是 <code>built-in</code> 的对象，即并不存在 <code>Function 对象由 Function 构造函数创建</code> 这样显然会造成鸡生蛋蛋生鸡的问题。实际上当直接写一个函数时（如 <code>function f() &#123;&#125;</code> 或 <code>x =&gt; x</code>），也不存在调用 <code>Function</code> 构造器，只有在显式调用 <code>Function</code> 构造器时（如 <code>new Function(&#39;x&#39;, &#39;return x&#39;)</code>）才有</p>
</li>
</ul>
<p>个人偏向于第二种解释，即先有 <code>Function.prototype</code> 然后有 <code>function Function()</code>，所以就不存在鸡生蛋蛋生鸡问题了，把 <code>Function.__proto__</code> 指向 <code>Function.prototype</code>，个人的理解是：</p>
<ul>
<li><p><strong>其他所有的构造函数都可以通过原型链找到 <code>Function.prototype</code>，且 <code>Function</code> 本质也是一个函数对象，事实上 Function 只是一个祖先、一个构造函数，并不是一个实例出来的函数对象，所以本来没必要拥有 <code>__proto__</code> 这个属性，但这样的话会显得 <code>Function</code> 很另类，于是也给它加上属性 <code>__proto__</code> 并指向 <code>Function.prototype</code></strong></p>
</li>
<li><p><strong>只是为了表明 <code>Function</code> 作为一个原生构造函数，本身也是一个函数对象，且这也保证了原型链的完整，让 <code>Function</code> 可以获取定义在 <code>Object.prototype</code> 上的方法</strong></p>
</li>
</ul>
<blockquote>
<p>一切函数对象（包括 <code>Object</code> 对象）都直接继承自 <code>Function</code> 对象，<code>Function</code> 对象直接继承自己，最终继承自 <code>Object</code> 对象，<code>Object</code> 和 <code>Function</code> 是互相继承的关系</p>
</blockquote>
<blockquote>
<p>有了 <code>Function.prototype</code> 以后才有了 <code>function Function()</code>，然后其他的构造函数都是 <code>function Function()</code> 生成的</p>
</blockquote>
<p>一切对象都继承自 <code>Object.prototype</code>，而一切<code>函数对象</code>都继承自 <code>Function.prototype</code> (<code>Function.prototype</code> 最终继承自 <code>Object.prototype</code>)，即可知道普通对象和函数对象的区别是：</p>
<ul>
<li>普通对象直接继承了 <code>Object.prototype</code>，而函数对象在中间还继承了 <code>Function.prototype</code></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>Object</code> 是所有对象的<code>爸爸</code>，所有对象都可以通过 <code>__proto__</code> 找到它 </li>
<li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它  </li>
<li>所有通过字面量表示法创建的普通对象的构造函数为 <code>Object</code></li>
<li>所有原型对象都是普通对象，构造函数为 <code>Object</code></li>
<li>所有函数的构造函数是 <code>Function</code></li>
<li><code>Function.prototype</code> 和 <code>Object.prototype</code> 没有原型对象  </li>
<li><code>Function.prototype</code> 和 <code>Object.prototype</code> 是两个由引擎创建出来的特殊对象，除了这两个特殊对象，其他对象都是通过构造器 <code>new</code> 出来的  </li>
<li>函数的 <code>prototype</code> 是一个对象，即原型。对象的 <code>__proto__</code> 指向原型，<code>__proto__</code> 将对象和原型连接起来组成了原型链  </li>
<li><code>Function.prototype.__proto__ === Object.prototype</code>  </li>
<li><code>Object.__proto__ === Function.prototype</code>  </li>
<li><code>Function.__proto__ === Function.prototype</code>  </li>
<li><code>Function.__proto__ === Object.__proto__</code>  </li>
<li><code>Object.prototype.__proto__ === null</code>  </li>
<li><code>Object =&gt; Function.prototype =&gt; Object.prototype =&gt; null</code>  </li>
<li><code>Function =&gt; Function.prototype =&gt; Object.prototype =&gt; null</code> </li>
<li>若是自定义的构造函数，形成的原型链如下：<code>Foo =&gt; Function.prototype =&gt; Object.prototype =&gt; null</code>  </li>
<li>通过自定义构造函数实例化的对象，形成的原型链如下：<code>obj =&gt; Foo.prototype =&gt; Object.prototype =&gt; null</code></li>
</ul>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example13.9kgayqd9yw.webp" alt="example13"></p>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example14.7snc3ttx2r.webp" alt="example14"></p>
<h2 id="内置类型构建过程"><a href="#内置类型构建过程" class="headerlink" title="内置类型构建过程"></a>内置类型构建过程</h2><p><code>JavaScript</code> 内置类型是浏览器内核自带的，浏览器底层对 <code>JavaScript</code> 的实现基于 <code>C/C++</code>，则浏览器在初始化 <code>JavaScript</code> 环境时都发生了什么？</p>
<ul>
<li>用 <code>C/C++</code> 构造内部数据结构创建一个 <code>OP</code> 即 <code>Object.prototype</code>，以及初始化其内部属性但不包括行为</li>
<li>用 <code>C/C++</code> 构造内部数据结构创建一个 <code>FP</code> 即 <code>Function.prototype</code>，以及初始化其内部属性但不包括行为</li>
<li>将 <code>FP</code> 的 <code>[[Prototype]]</code> 指向 <code>OP</code></li>
<li>用 <code>C/C++</code> 构造内部数据结构创建各种内置引用类型</li>
<li>将各内置引用类型的 <code>[[Prototype]]</code> 指向 <code>FP</code></li>
<li>将 <code>Function</code> 的 <code>prototype</code> 指向 <code>FP</code></li>
<li>将 <code>Object</code> 的 <code>prototype</code> 指向 <code>OP</code></li>
<li>用 <code>Function</code> 实例化出 <code>OP</code>、<code>FP</code>，以及 <code>Object</code> 的行为并挂载</li>
<li>用 <code>Object</code> 实例化出除 <code>Object</code> 以及 <code>Function</code> 的其他内置引用类型的 <code>prototype</code> 属性对象</li>
<li>用 <code>Function</code> 实例化出除 <code>Object</code> 以及 <code>Function</code> 的其他内置引用类型的 <code>prototype</code> 属性对象的行为并挂载</li>
<li>实例化内置对象 <code>Math</code> 以及 <code>Grobal</code> 至此所有内置类型构建完成</li>
</ul>
<h1 id="原型污染"><a href="#原型污染" class="headerlink" title="原型污染"></a>原型污染</h1><p>曾经 <code>Lodash</code> 爆出了一个严重的安全漏洞：<a href="https://link.juejin.cn/?target=https://mp.weixin.qq.com/s/tfZq2PZylGfMjOp8h8eeTw" title="https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;tfZq2PZylGfMjOp8h8eeTw">Lodash 库爆出严重安全漏洞，波及 400 万+项目</a>，这个安全漏洞就是由于原型污染导致的，<code>Lodash</code> 库中的函数<code>defaultsDeep</code>很有可能会被欺骗添加或修改 <code>Object.prototype</code> 的属性，最终可能导致 <code>Web</code> 应用程序崩溃或改变其行为，具体取决于受影响的用例</p>
<p>虽说任何一个原型被污染了都有可能导致问题，但一般提原型污染说的就是 <code>Object.prototype</code> 被污染</p>
<h2 id="原型污染的危害"><a href="#原型污染的危害" class="headerlink" title="原型污染的危害"></a>原型污染的危害</h2><p>性能问题：原型被污染会增加遍历的次数，每次访问对象自身不存在的属性时也要访问原型上被污染的属性</p>
<p>导致意外的逻辑 <code>bug</code>：看下面这个从别的大佬的文章中看到的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bodyParser = <span class="built_in">require</span>(<span class="string">&#x27;body-parser&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> cookieParser = <span class="built_in">require</span>(<span class="string">&#x27;cookie-parser&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">isObject</span> = (<span class="params">obj</span>) =&gt; obj &amp;&amp; obj.<span class="property">constructor</span> &amp;&amp; obj.<span class="property">constructor</span> === <span class="title class_">Object</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">merge</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> attr <span class="keyword">in</span> b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_">isObject</span>(a[attr]) &amp;&amp; <span class="title function_">isObject</span>(b[attr])) &#123;</span><br><span class="line">      <span class="title function_">merge</span>(a[attr], b[attr]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      a[attr] = b[attr];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">clone</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">merge</span>(&#123;&#125;, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Constants</span></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PORT</span> = <span class="number">8080</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">HOST</span> = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> admin = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// App</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>();</span><br><span class="line">app.<span class="title function_">use</span>(bodyParser.<span class="title function_">json</span>());</span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cookieParser</span>());</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="string">&#x27;/&#x27;</span>, express.<span class="title function_">static</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;views&#x27;</span>)));</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/signup&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> body = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(req.<span class="property">body</span>));</span><br><span class="line">  <span class="keyword">var</span> copybody = <span class="title function_">clone</span>(body);</span><br><span class="line">  <span class="keyword">if</span> (copybody.<span class="property">name</span>) &#123;</span><br><span class="line">    res.<span class="title function_">cookie</span>(<span class="string">&#x27;name&#x27;</span>, copybody.<span class="property">name</span>).<span class="title function_">json</span>(&#123;</span><br><span class="line">      <span class="attr">done</span>: <span class="string">&#x27;cookie set&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.<span class="title function_">json</span>(&#123;</span><br><span class="line">      <span class="attr">error</span>: <span class="string">&#x27;cookie not set&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/getFlag&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">var</span> аdmin = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(req.<span class="property">cookies</span>));</span><br><span class="line">  <span class="keyword">if</span> (admin.аdmin == <span class="number">1</span>) &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;hackim19&#123;&#125;&#x27;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&#x27;You are not authorized&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">app.<span class="title function_">listen</span>(<span class="variable constant_">PORT</span>, <span class="variable constant_">HOST</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Running on http://<span class="subst">$&#123;HOST&#125;</span>:<span class="subst">$&#123;PORT&#125;</span>`</span>);</span><br></pre></td></tr></table></figure>

<p>这段代码的漏洞就在于 <code>merge</code> 函数上，可以这样攻击：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -vv --header <span class="string">&#x27;Content-type: application/json&#x27;</span> -d <span class="string">&#x27;&#123;&quot;__proto__&quot;: &#123;&quot;admin&quot;: 1&#125;&#125;&#x27;</span> <span class="string">&#x27;http://127.0.0.1:4000/signup&#x27;</span>;</span><br><span class="line"></span><br><span class="line">curl -vv <span class="string">&#x27;http://127.0.0.1/getFlag&#x27;</span></span><br></pre></td></tr></table></figure>

<p>首先请求 <code>/signup</code> 接口，在 <code>NodeJS</code> 服务中调用了有漏洞的 <code>merge</code> 方法，并通过 <code>__proto__</code> 为 <code>Object.prototype</code>（因为 <code>&#123;&#125;.__proto__ === Object.prototype</code>） 添加上一个新的属性 <code>admin</code> 且值为 <code>1</code></p>
<p>再次请求 <code>getFlag</code> 接口访问了 <code>Object</code> 原型上的 <code>admin</code>，条件语句 <code>admin.аdmin == 1</code> 为 <code>true</code>，服务被攻击</p>
<h2 id="预防原型污染"><a href="#预防原型污染" class="headerlink" title="预防原型污染"></a>预防原型污染</h2><p>实际情况下，原型污染大多发生在调用会修改或扩展对象属性的函数时，如 <code>Lodash</code> 的 <code>defaults</code>、<code>jQuery</code> 的 <code>extend</code>，预防原型污染最主要还是要有防患意识，养成良好的编码习惯</p>
<h3 id="Object-create-null"><a href="#Object-create-null" class="headerlink" title="Object.create(null)"></a>Object.create(null)</h3><p><code>Object.create(null)</code> 创建没有原型的对象，即便对它设置 <code>__proto__</code> 也没用，因为它的原型一开始就是 <code>null</code>，没有 <code>__proro__</code> 的 <code>setter</code></p>
<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example15.9gwp10k78j.webp" alt="example15"></p>
<h3 id="Object-freeze-obj"><a href="#Object-freeze-obj" class="headerlink" title="Object.freeze(obj)"></a>Object.freeze(obj)</h3><p>可以通过 <code>Object.freeze(obj)</code> 冻结对象 <code>obj</code>，被冻结的对象不能被修改属性，成为不可扩展对象。不能修改、不可扩展对象的原型，否则会抛 <code>TypeError</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">freeze</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;xiaoHong&#x27;</span> &#125;);</span><br><span class="line">obj.<span class="property">xxx</span> = <span class="number">666</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj); <span class="comment">// =&gt; &#123; name: &#x27;xiaoHong&#x27; &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">isExtensible</span>(obj)); <span class="comment">// =&gt; false</span></span><br><span class="line">obj.<span class="property">__proto__</span> = <span class="literal">null</span>; <span class="comment">// =&gt; TypeError: #&lt;Object&gt; is not extensible</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>关于原型污染可阅读：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903887686598663">Lodash 严重安全漏洞背后你不得不知道的 JavaScript 知识</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://donnapersonal.github.io/cn">Donna Tang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://donnapersonal.github.io/cn/posts/jsbasic-prototype/">https://donnapersonal.github.io/cn/posts/jsbasic-prototype/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://donnapersonal.github.io/cn" target="_blank">Donna'Log</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/cn/tags/JS/">JS</a></div><div class="post-share"><div class="social-share" data-image="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.73ubpkycwk.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/cn/posts/jsbasic-handwriting/" title="JavaScript 基础 - 高频手写"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9ddc96s40g.webp" onerror="onerror=null;src='/cn/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JavaScript 基础 - 高频手写</div></div><div class="info-2"><div class="info-item-1">模拟 Object.is()Object.is() 在 === 的基础上修复了一些特殊情况下的失误，具体来说就是：  +0 不等于 -0 NaN 等于自身  1234567891011function objectIs(x, y) &#123;  if(x === y) &#123;    // 运行到 1/x === 1/y 时 x 和 y 都为 0    // 但 1/+0 = +Infinity，1/-0 = -Infinity 是不一样的    return x !== 0 || y !== 0 || 1 / x === 1 / y;  &#125; else &#123;    // NaN === NaN 是 false，在这里做个拦截，x !== x 一定是 NaN, y 同理    // 两个都是 NaN 时返回 true    return x !== x &amp;&amp; y !== y;  &#125;&#125;  模拟 new当执行 new Foo(...) 时，会发生以下事情：  一个继承自 Foo.prototype 的新对象被创建 使用指定的参...</div></div></div></a><a class="pagination-related" href="/cn/posts/jsbasic-inherit/" title="JavaScript 基础 - 继承"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2rvii9f6z2.webp" onerror="onerror=null;src='/cn/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">JavaScript 基础 - 继承</div></div><div class="info-2"><div class="info-item-1">继承原型存在的意义就是组成原型链：引用类型皆对象，每个对象都有原型，原型也是对象，也有它自己的原型，一层一层的组成了原型链 原型链存在的意义就是继承：访问对象属性时，在对象本身找不到，就在原型链上一层一层往上找，说白了就是一个对象可以访问其他对象的属性 继承存在的意义就是属性共享：  好处一是代码重用（字面意思） 好处二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性  ES5 继承实现方式原型链继承原理：将父类的实例作为子类的原型 12345678910111213141516171819202122232425function Parent() &#123;  this.name = &#x27;tn&#x27;;&#125;Parent.prototype.getName = function () &#123;  console.log(this.name);&#125;function Son () &#123;&#125;;// 关键，创建 Parent 的实例并将该实例赋值给 Son.prototypeSon.prototype = new Pare...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/cn/posts/+operator/" title="JS 的 {} + {} 与 {} + [] 的结果是什么？"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.8s3omkauw3.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="info-item-2">JS 的 {} + {} 与 {} + [] 的结果是什么？</div></div><div class="info-2"><div class="info-item-1">前言在 JS 中，+ 符号是很常见的一种，它有以下的使用情况：  数字的加法运算，二元运算 字符串的连接运算，二元运算，优先级最高 正号，一元运算，可延伸为强制转换其他类型的运算元为数字类型  另一个常见的是花括号 &#123;&#125;，它有两个用途也很常见：  对象的字面定义 区块语句  加号运算符 +除了上面说明的常见情况外，在标准中转换的规则还有以下几个，要注意它的顺序：operand + operand = result  使用 ToPrimitive 运算转换左与右运算元为原始数据类型值 (primitive) 在第 1 步转换后，若有运算元出现原始数据类型是&quot;字符串&quot;类型值时，则另一运算元作强制转换为字符串，然后作字符串的连接运算 (concatenation) 其他情况时，所有运算元都会转换为原始数据类型的&quot;数字&quot;类型，然后作数学的相加运算(addition)  ToPrimitive 内部运算因此，加号运算符只能使用于原始数据类型，那么对于对象类型的值要如何转换为原始数据类型？ JavaScript 对象转换到基本类型值...</div></div></div></a><a class="pagination-related" href="/cn/posts/0.1+0.2/" title="为什么 0.1 + 0.2 !&#x3D;&#x3D; 0.3"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.6m494gp9dv.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="info-item-2">为什么 0.1 + 0.2 !&#x3D;&#x3D; 0.3</div></div><div class="info-2"><div class="info-item-1">背景在浏览器控制台窗口输入以下两行代码，结果出乎意料 1230.1 + 0.2 &gt; 0.3  // true0.1 + 0.2 = 0.300000000000000040.1 * 0.1 = 0.010000000000000002  前置知识在计算机的世界里，应该是只有二进制数据的，不是 0 就是 1，为了表达生活中最为常见的十进制数据，则就会有个转换过程 十进制转为二进制十进制转换为二进制这个过程整体总结就是：  整数采用整数除 2 取余，直到商为 0 时为止，将余数逆序排列 小数采用小数部分乘以 2，取整，直到得到小数部分 0 或达到所要求的精度为止，将整数顺序排列  二进制转为十进制12345678910111213// 以二进制 10101101.1101 为例  // 针对整数部分 10101101 计算逻辑如下// ← 从右往左1 * 2^0 + 0 * 2^1 + 1 * 2^2 + 1 * 2^3 + 0 * 2^4 + 1 * 2^5 + 0 * 2^6 + 1 * 2^7= 1 + 0 + 4 + 8 + 0 + 32 + 0 + 128= 173/...</div></div></div></a><a class="pagination-related" href="/cn/posts/jsbasic-datatype/" title="JavaScript 基础 - 数据类型、运算符、类型转换"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.7i0rgcc8cp.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="info-item-2">JavaScript 基础 - 数据类型、运算符、类型转换</div></div><div class="info-2"><div class="info-item-1">数据类型原始（Primitive）类型原始（Primitive）值一般叫做栈数据（一旦开了个房间、不可能在这个房间里对其进行修改） 在 JS 中，存在着以下几种原始值，分别是：  number（typeof 1 === &quot;number&quot;） string（typeof &#39;&#39; === &quot;string&quot;） boolean（typeof true === &quot;boolean&quot;） null（typeof null === &quot;object&quot;） undefined（typeof undefined === &quot;undefined&quot;） symbol（typeof Symbol() === &quot;symbol&quot;） bigInt（typeof 10n === &quot;bigint&quot;）(没有正式发布但即将被加入标准的原始类型)  原始类型存储的都是值，是没有函数可以调用的，如 undefined.toString() 会报错，一般看到的 &#39;1&#39;....</div></div></div></a><a class="pagination-related" href="/cn/posts/jsbasic-handwriting/" title="JavaScript 基础 - 高频手写"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9ddc96s40g.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-09</div><div class="info-item-2">JavaScript 基础 - 高频手写</div></div><div class="info-2"><div class="info-item-1">模拟 Object.is()Object.is() 在 === 的基础上修复了一些特殊情况下的失误，具体来说就是：  +0 不等于 -0 NaN 等于自身  1234567891011function objectIs(x, y) &#123;  if(x === y) &#123;    // 运行到 1/x === 1/y 时 x 和 y 都为 0    // 但 1/+0 = +Infinity，1/-0 = -Infinity 是不一样的    return x !== 0 || y !== 0 || 1 / x === 1 / y;  &#125; else &#123;    // NaN === NaN 是 false，在这里做个拦截，x !== x 一定是 NaN, y 同理    // 两个都是 NaN 时返回 true    return x !== x &amp;&amp; y !== y;  &#125;&#125;  模拟 new当执行 new Foo(...) 时，会发生以下事情：  一个继承自 Foo.prototype 的新对象被创建 使用指定的参...</div></div></div></a><a class="pagination-related" href="/cn/posts/jsbasic-inherit/" title="JavaScript 基础 - 继承"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2rvii9f6z2.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="info-item-2">JavaScript 基础 - 继承</div></div><div class="info-2"><div class="info-item-1">继承原型存在的意义就是组成原型链：引用类型皆对象，每个对象都有原型，原型也是对象，也有它自己的原型，一层一层的组成了原型链 原型链存在的意义就是继承：访问对象属性时，在对象本身找不到，就在原型链上一层一层往上找，说白了就是一个对象可以访问其他对象的属性 继承存在的意义就是属性共享：  好处一是代码重用（字面意思） 好处二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性  ES5 继承实现方式原型链继承原理：将父类的实例作为子类的原型 12345678910111213141516171819202122232425function Parent() &#123;  this.name = &#x27;tn&#x27;;&#125;Parent.prototype.getName = function () &#123;  console.log(this.name);&#125;function Son () &#123;&#125;;// 关键，创建 Parent 的实例并将该实例赋值给 Son.prototypeSon.prototype = new Pare...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/cn/img/avatar.JPG" onerror="this.onerror=null;this.src='/cn/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Donna Tang</div><div class="author-info-description">Learn more! Think more! Do more!</div><div class="site-data"><a href="/cn/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/cn/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/cn/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/donnapersonal"><i class="fab fa-github"></i><span>GitHub</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog! <br>Migrating from old blog!</br></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">什么是构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Symbol-%E6%98%AF%E5%90%A6%E6%98%AF%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.2.</span> <span class="toc-text">Symbol 是否是构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constructor-%E5%80%BC%E6%98%AF%E5%90%A6%E5%8F%AA%E8%AF%BB"><span class="toc-number">1.3.</span> <span class="toc-text">constructor 值是否只读</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-new"><span class="toc-number">1.4.</span> <span class="toc-text">模拟实现 new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E8%A2%AB-new-%E8%B0%83%E7%94%A8%E8%80%8C%E4%B8%8D%E8%83%BD%E8%A2%AB%E6%99%AE%E9%80%9A%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">扩展：如何确保构造函数只能被 new 调用而不能被普通调用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%EF%BC%9A%E6%97%A2%E7%84%B6-Class-%E5%BF%85%E9%A1%BB%E4%BD%BF%E7%94%A8-new-%E6%9D%A5%E8%B0%83%E7%94%A8%EF%BC%8C%E9%82%A3-new-target-%E5%B1%9E%E6%80%A7%E7%9A%84%E6%84%8F%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">扩展：既然 Class 必须使用 new 来调用，那 new.target 属性的意义是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text">函数对象和普通对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%EF%BC%88prototype%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">原型（prototype）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#constructor-NaN"><span class="toc-number">3.2.</span> <span class="toc-text">constructor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#proto"><span class="toc-number">3.3.</span> <span class="toc-text">__proto__</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-create"><span class="toc-number">3.4.</span> <span class="toc-text">Object.create()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">4.</span> <span class="toc-text">原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E4%B8%8A%E5%B1%9E%E6%80%A7%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5"><span class="toc-number">4.2.</span> <span class="toc-text">原型链上属性的增删改查</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#instanceof-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">instanceof 操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-2"><span class="toc-number">5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.</span> <span class="toc-text">模拟实现</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Object-Function"><span class="toc-number">6.</span> <span class="toc-text">Object &amp; Function</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-prototype"><span class="toc-number">6.1.</span> <span class="toc-text">Object.prototype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-prototype"><span class="toc-number">6.2.</span> <span class="toc-text">Function.prototype</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object"><span class="toc-number">6.3.</span> <span class="toc-text">Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function"><span class="toc-number">6.4.</span> <span class="toc-text">Function</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Function-Object-%E9%B8%A1%E8%9B%8B%E9%97%AE%E9%A2%98"><span class="toc-number">6.5.</span> <span class="toc-text">Function &amp; Object 鸡蛋问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">6.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E7%B1%BB%E5%9E%8B%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">6.7.</span> <span class="toc-text">内置类型构建过程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93"><span class="toc-number">7.</span> <span class="toc-text">原型污染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93%E7%9A%84%E5%8D%B1%E5%AE%B3"><span class="toc-number">7.1.</span> <span class="toc-text">原型污染的危害</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E9%98%B2%E5%8E%9F%E5%9E%8B%E6%B1%A1%E6%9F%93"><span class="toc-number">7.2.</span> <span class="toc-text">预防原型污染</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-create-null"><span class="toc-number">7.2.1.</span> <span class="toc-text">Object.create(null)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-freeze-obj"><span class="toc-number">7.2.2.</span> <span class="toc-text">Object.freeze(obj)</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/jsbasic-handwriting/" title="JavaScript 基础 - 高频手写"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9ddc96s40g.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="JavaScript 基础 - 高频手写"/></a><div class="content"><a class="title" href="/cn/posts/jsbasic-handwriting/" title="JavaScript 基础 - 高频手写">JavaScript 基础 - 高频手写</a><time datetime="2021-07-10T01:10:53.000Z" title="发表于 2021-07-09 21:10:53">2021-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/jsbasic-inherit/" title="JavaScript 基础 - 继承"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2rvii9f6z2.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="JavaScript 基础 - 继承"/></a><div class="content"><a class="title" href="/cn/posts/jsbasic-inherit/" title="JavaScript 基础 - 继承">JavaScript 基础 - 继承</a><time datetime="2021-07-09T01:10:53.000Z" title="发表于 2021-07-08 21:10:53">2021-07-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/jsbasic-prototype/" title="JavaScript 基础 - 重新认识构造函数、原型、原型链、继承"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.73ubpkycwk.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="JavaScript 基础 - 重新认识构造函数、原型、原型链、继承"/></a><div class="content"><a class="title" href="/cn/posts/jsbasic-prototype/" title="JavaScript 基础 - 重新认识构造函数、原型、原型链、继承">JavaScript 基础 - 重新认识构造函数、原型、原型链、继承</a><time datetime="2021-07-09T01:10:53.000Z" title="发表于 2021-07-08 21:10:53">2021-07-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/0.1+0.2/" title="为什么 0.1 + 0.2 !== 0.3"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.6m494gp9dv.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="为什么 0.1 + 0.2 !== 0.3"/></a><div class="content"><a class="title" href="/cn/posts/0.1+0.2/" title="为什么 0.1 + 0.2 !== 0.3">为什么 0.1 + 0.2 !== 0.3</a><time datetime="2021-05-17T01:35:51.000Z" title="发表于 2021-05-16 21:35:51">2021-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/jsbasic-datatype/" title="JavaScript 基础 - 数据类型、运算符、类型转换"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.7i0rgcc8cp.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="JavaScript 基础 - 数据类型、运算符、类型转换"/></a><div class="content"><a class="title" href="/cn/posts/jsbasic-datatype/" title="JavaScript 基础 - 数据类型、运算符、类型转换">JavaScript 基础 - 数据类型、运算符、类型转换</a><time datetime="2021-05-16T19:49:09.000Z" title="发表于 2021-05-16 15:49:09">2021-05-16</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By Donna Tang</span></div><div class="footer_custom_text">Hi, welcome to my blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/cn/js/utils.js"></script><script src="/cn/js/main.js"></script><div class="js-pjax"></div><script data-pjax src="/self/btf.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/cn/404') : window.location.href = '/cn/404')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/cn/js/search/local-search.js"></script></div></div></body></html>
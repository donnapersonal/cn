<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>JavaScript 基础 - 继承 | Donna'Log</title><meta name="author" content="Donna Tang"><meta name="copyright" content="Donna Tang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="继承原型存在的意义就是组成原型链：引用类型皆对象，每个对象都有原型，原型也是对象，也有它自己的原型，一层一层的组成了原型链 原型链存在的意义就是继承：访问对象属性时，在对象本身找不到，就在原型链上一层一层往上找，说白了就是一个对象可以访问其他对象的属性 继承存在的意义就是属性共享：  好处一是代码重用（字面意思） 好处二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性  ES5 继">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript 基础 - 继承">
<meta property="og:url" content="https://donnapersonal.github.io/cn/posts/jsbasic-inherit/">
<meta property="og:site_name" content="Donna&#39;Log">
<meta property="og:description" content="继承原型存在的意义就是组成原型链：引用类型皆对象，每个对象都有原型，原型也是对象，也有它自己的原型，一层一层的组成了原型链 原型链存在的意义就是继承：访问对象属性时，在对象本身找不到，就在原型链上一层一层往上找，说白了就是一个对象可以访问其他对象的属性 继承存在的意义就是属性共享：  好处一是代码重用（字面意思） 好处二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性  ES5 继">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2rvii9f6z2.webp">
<meta property="article:published_time" content="2021-07-09T01:10:53.000Z">
<meta property="article:modified_time" content="2025-10-03T01:55:26.959Z">
<meta property="article:author" content="Donna Tang">
<meta property="article:tag" content="JS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2rvii9f6z2.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "JavaScript 基础 - 继承",
  "url": "https://donnapersonal.github.io/cn/posts/jsbasic-inherit/",
  "image": "https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2rvii9f6z2.webp",
  "datePublished": "2021-07-09T01:10:53.000Z",
  "dateModified": "2025-10-03T01:55:26.959Z",
  "author": [
    {
      "@type": "Person",
      "name": "Donna Tang",
      "url": "https://donnapersonal.github.io/cn"
    }
  ]
}</script><link rel="shortcut icon" href="/cn/img/favicon.png"><link rel="canonical" href="https://donnapersonal.github.io/cn/posts/jsbasic-inherit/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/cn/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/cn/',
  algolia: undefined,
  localSearch: {"path":"/cn/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: Donna Tang","link":"链接: ","source":"来源: Donna'Log","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript 基础 - 继承',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="preconnect" href="https://jsd.012700.xyz"><link href="/self/btf.css" rel="stylesheet"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(https://oss.012700.xyz/butterfly/2024/10/index.jpg);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/cn/img/avatar.JPG" onerror="this.onerror=null;this.src='/cn/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/cn/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/cn/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/cn/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/cn/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/cn/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/cn/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/cn/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://donnapersonal.github.io/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/cn/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/cn/"><span class="site-name">Donna'Log</span></a><a class="nav-page-title" href="/cn/"><span class="site-name">JavaScript 基础 - 继承</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/cn/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/cn/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/cn/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/cn/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-language"></i><span> 语言</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="https://donnapersonal.github.io/"><i class="fa-fw fas fa-e"></i><span> English</span></a></li><li><a class="site-page child" href="/cn/"><i class="fa-fw fas fa-c"></i><span> 中文</span></a></li></ul></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">JavaScript 基础 - 继承<a class="post-edit-link" href="null_posts/jsbasic-inherit.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-07-09T01:10:53.000Z" title="发表于 2021-07-08 21:10:53">2021-07-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-03T01:55:26.959Z" title="更新于 2025-10-02 21:55:26">2025-10-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/cn/categories/Frontend/">Frontend</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/cn/categories/Frontend/JS/">JS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p><strong>原型存在的意义就是组成原型链</strong>：引用类型皆对象，每个对象都有原型，原型也是对象，也有它自己的原型，一层一层的组成了原型链</p>
<p><strong>原型链存在的意义就是继承</strong>：访问对象属性时，在对象本身找不到，就在原型链上一层一层往上找，说白了就是一个对象可以访问其他对象的属性</p>
<p><strong>继承存在的意义就是属性共享</strong>：</p>
<ul>
<li>好处一是代码重用（字面意思）</li>
<li>好处二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性</li>
</ul>
<h1 id="ES5-继承实现方式"><a href="#ES5-继承实现方式" class="headerlink" title="ES5 继承实现方式"></a>ES5 继承实现方式</h1><h2 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h2><p>原理：<strong>将父类的实例作为子类的原型</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;tn&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">getName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line"><span class="comment">// 关键，创建 Parent 的实例并将该实例赋值给 Son.prototype</span></span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">const</span> son1 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son1.<span class="title function_">getName</span>());  <span class="comment">// tn </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺点</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">names</span> = [<span class="string">&#x27;licy&#x27;</span>, <span class="string">&#x27;tn&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span> (<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Son</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>();</span><br><span class="line"><span class="keyword">const</span> son1 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line">son1.<span class="property">names</span>.<span class="title function_">push</span>(<span class="string">&#x27;yayu&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son1.<span class="property">names</span>); <span class="comment">// [&quot;licy&quot;, &quot;tn&quot;, &quot;yayu&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son2 = <span class="keyword">new</span> <span class="title class_">Son</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son2.<span class="property">names</span>); <span class="comment">// [&quot;licy&quot;, &quot;tn&quot;, &quot;yayu&quot;]</span></span><br></pre></td></tr></table></figure>

<p><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/example16.b90xcg6n3.webp" alt="example16"></p>
<p>优点：父类方法可以复用，父类的属性与方法子类都能访问</p>
<p>缺点：</p>
<ul>
<li>父类的引用属性会被所有子类实例共享，子类会继承过多没有用的属性，造成大量的浪费且多个实例对引用类型的操作会被篡改</li>
<li>由于子类实现的继承是靠其原型 <code>prototype</code> 对父类进行实例化实现的，因此在构建子类实例时是无法向父类传递参数的，因而在实例化父类时也无法对父类构造函数内的属性进行初始化</li>
</ul>
<h2 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h2><p>原理：使用父类的构造函数来增强子类实例，利用 <code>call</code> 和 <code>apply</code> 可改变 <code>this</code> 指向的特点，将父类构造函数内容复制给子类构造函数，由于父类中给 <code>this</code> 绑定属性，因此子类自然也就继承父类的共有属性</p>
<blockquote>
<p>这是所有继承中唯一不涉及到 <code>prototype</code> 的继承</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Parent</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">books</span> = [<span class="string">&#x27;js&#x27;</span>,<span class="string">&#x27;css&#x27;</span>];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Parent</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">showBooks</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">books</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Son</span> (<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> son1 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;tn&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son1.<span class="property">name</span>); <span class="comment">// tn</span></span><br><span class="line">son1.<span class="title function_">showBooks</span>(); <span class="comment">// TypeError: son1.showBooks is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> son2 = <span class="keyword">new</span> <span class="title class_">Son</span>(<span class="string">&#x27;licy&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(son2.<span class="property">name</span>); <span class="comment">// licy</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span>=[<span class="string">&quot;red&quot;</span>,<span class="string">&quot;green&quot;</span>,<span class="string">&quot;blue&quot;</span>]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>)&#123; </span><br><span class="line">  <span class="comment">//继承自 SuperType </span></span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line">instance1.<span class="property">color</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">color</span>); <span class="comment">//[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;black&quot;] </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">color</span>); <span class="comment">//[&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>父类的引用属性不会被共享，避免了引用类型的属性被所有实例共享且避免了多个实例对引用类型的操作会被篡改的问题</li>
<li>子类构建实例时可以向父类传递参数</li>
</ul>
<p>缺点：</p>
<ul>
<li>不能继承父类原型上的属性&#x2F;方法（若原型上的属性&#x2F;方法想被子类继承，就必须放到构造函数中）</li>
<li>父类的方法和属性不能复用，子类实例的方法每次都是单独创建的，这样就违背了代码复用的原则</li>
<li>每个子类都有父类实例函数的副本，影响性能</li>
</ul>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><blockquote>
<p><code>原型链继承</code> 和 <code>借用构造函数继承</code> 结合</p>
</blockquote>
<p>原理：用原型链实现对原型属性和方法的继承，用借用构造函数技术来实现实例属性的继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name; </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;    </span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>); &#125;; </span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123; </span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="comment">// 第二次调用 SuperType() </span></span><br><span class="line">  <span class="comment">// 第二次又给子类的构造函数添加了父类的 name, colors 属性</span></span><br><span class="line">  <span class="comment">// 使用子类创建的实例对象上的同名属性覆盖了子类原型中的同名属性，这造成了性能浪费</span></span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name); </span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 继承方法，构建原型链 </span></span><br><span class="line"><span class="comment">// 第一次调用 SuperType() </span></span><br><span class="line"><span class="comment">// 第一次给子类的原型添加了父类的 name, colors 属性</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">// 重写 SubType.prototype 的 constructor 属性，指向自己的构造函数 SubType </span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">SubType</span>; </span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; <span class="title function_">alert</span>(<span class="variable language_">this</span>.<span class="property">age</span>); &#125;; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>); </span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>); <span class="comment">//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]</span></span><br><span class="line">instance1.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Nicholas&quot;; </span></span><br><span class="line">instance1.<span class="title function_">sayAge</span>(); <span class="comment">//29 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">//[&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]</span></span><br><span class="line">instance2.<span class="title function_">sayName</span>(); <span class="comment">//&quot;Greg&quot;; </span></span><br><span class="line">instance2.<span class="title function_">sayAge</span>(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure>

<p>优点：</p>
<ul>
<li>父类的方法可以被复用</li>
<li>父类的引用属性不会被共享</li>
<li>子类构建实例时可以向父类传递参数</li>
<li>可以继承父类的属性和方法，同时也可以继承原型的属性和方法</li>
</ul>
<p>缺点：</p>
<ul>
<li>使用子类创建实例对象时，父类调用了两次，因此产生了两份实例，其原型中会存在两份相同的属性&#x2F;方法</li>
</ul>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>ES5 <code>Object.create</code> 的模拟实现，利用一个空对象作为中介，将传入的对象作为该空对象构造函数的原型，<code>object()</code> 对传入的对象执行了一次浅复制</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">obj</span>)&#123;</span><br><span class="line">  <span class="comment">// 声明一个过渡对象 </span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;;</span><br><span class="line">  <span class="comment">// 过渡对象的原型继承传入的对象</span></span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="comment">// 返回过渡对象的实例</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123; </span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>, </span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>] </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> anotherPerson = <span class="title function_">object</span>(person); </span><br><span class="line"><span class="keyword">const</span> yetAnotherPerson = <span class="title function_">object</span>(person); </span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>; </span><br><span class="line">anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Rob&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(anotherPerson.<span class="property">name</span>) <span class="comment">// &quot;Greg&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(yetAnotherPerson.<span class="property">name</span>) <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(yetAnotherPerson.<span class="property">friends</span>) <span class="comment">//[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;]</span></span><br></pre></td></tr></table></figure>

<p>缺点：</p>
<ul>
<li>父类的引用类型的属性值会被所有子类实例共享，改动一个会影响另一个，这点跟原型链继承一样</li>
<li>子类构建实例时不能向父类传递参数</li>
</ul>
<p><code>ES5</code> 中 <code>Object.create()</code> 的方法能够代替上面的 <code>object</code>方法，<code>Object.create()</code> 方法规范化了原型式继承</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><ul>
<li>在原型式继承的基础上，创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来增强对象，最后返回对象</li>
<li>这样新创建的对象不仅仅有父类的属性和方法，还可新增了别的属性和方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>)&#123; </span><br><span class="line">  <span class="keyword">const</span> clone = <span class="title function_">object</span>(original); <span class="comment">// 通过调用 object() 函数创建一个新对象 </span></span><br><span class="line">  <span class="comment">// 或</span></span><br><span class="line">  <span class="keyword">const</span> clone = <span class="title class_">Object</span>.<span class="title function_">create</span>(o);</span><br><span class="line">  clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>)&#123; </span><br><span class="line">    <span class="comment">// 以某种方式来增强对象 </span></span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&quot;hi&quot;</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone; <span class="comment">// 返回这个对象 </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="title function_">createAnother</span>(person);</span><br><span class="line">anotherPerson.<span class="title function_">sayHi</span>(); <span class="comment">//&quot;hi&quot;</span></span><br></pre></td></tr></table></figure>

<p>缺点（同原型式继承）</p>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>寄生组合式继承是寄生式继承和借用构造函数继承的组合，只调用了一次父类构造函数，解决了组合继承有会两次调用父类的构造函数造成浪费的缺点</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="comment">//声明一个过渡对象</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  <span class="comment">//过渡对象的原型继承父对象</span></span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">  <span class="comment">//返回过渡对象的实例，该对象的原型继承了父对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">prototype</span>(<span class="params">child, parent</span>) &#123;</span><br><span class="line">  <span class="comment">// 复制一份父类的原型副本到变量中</span></span><br><span class="line">  <span class="keyword">const</span> prototype = <span class="title function_">object</span>(parent.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 增强对象，修正因为重写子类的原型导致子类的 `constructor` 属性被修改</span></span><br><span class="line">  prototype.<span class="property">constructor</span> = child;</span><br><span class="line">   <span class="comment">// 设置子类原型</span></span><br><span class="line">  child.<span class="property"><span class="keyword">prototype</span></span> = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用时</span></span><br><span class="line"><span class="title function_">prototype</span>(<span class="title class_">Child</span>, <span class="title class_">Parent</span>);</span><br></pre></td></tr></table></figure>

<p>引用<code>《JavaScript高级程序设计》</code>中对寄生组合式继承的夸赞就是：</p>
<ul>
<li>这种方式的高效率体现它只调用了一次 <code>Parent</code> 构造函数并且因此避免了在 <code>Parent.prototype</code> 上面创建不必要的、多余的属性</li>
<li>与此同时原型链还能保持不变，因此能够正常使用 <code>instanceof</code> 和 <code>isPrototypeOf</code></li>
<li>开发人员普遍认为寄生组合式继承是引用类型最理想的继承范式，也是现在很多库实现的方法</li>
</ul>
<p><strong>封装</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inherit</span> (<span class="params">Target, Origin</span>) &#123;</span><br><span class="line">  <span class="comment">// 声明一个过渡对象</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">  <span class="comment">// 过渡对象的原型继承父对象，创建了父类原型的浅复制</span></span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Origin</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  <span class="comment">// 返回过渡对象的实例，该对象的原型继承了父对象</span></span><br><span class="line">  <span class="title class_">Target</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">  <span class="comment">// 修正子类原型的构造函数</span></span><br><span class="line">  <span class="title class_">Target</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Target</span>;</span><br><span class="line">  <span class="comment">// 无法知道自己真正继承至谁（记住最好，也不强求）</span></span><br><span class="line">  <span class="comment">// 为了保存一下它的父类，也用一个 uber 来记录一下父类</span></span><br><span class="line">  <span class="comment">// 因为 super 是保留字不能使用，所以使用了 uber</span></span><br><span class="line">  <span class="title class_">Target</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">uber</span> = <span class="title class_">Origin</span>.<span class="property"><span class="keyword">prototype</span></span>; </span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>

<p>雅虎的高端写法，采用闭包的私有化变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> inherit = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">Target, Origin</span>) &#123;</span><br><span class="line">    F.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Origin</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">    <span class="title class_">Target</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">    <span class="title class_">Target</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">Target</span>;</span><br><span class="line">    <span class="title class_">Target</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">uber</span> = <span class="title class_">Origin</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;());      </span><br></pre></td></tr></table></figure>

<h2 id="混入方式继承多个对象"><a href="#混入方式继承多个对象" class="headerlink" title="混入方式继承多个对象"></a>混入方式继承多个对象</h2><p><code>Object.assign</code> 会把 <code>OtherSuperClass</code> 原型上的方法属性拷贝到 <code>MyClass</code> 原型上，使 <code>MyClass</code> 的所有实例都可使用 <code>OtherSuperClass</code> 上的方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">MyClass</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="title class_">SuperClass</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">  <span class="title class_">OtherSuperClass</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承一个类</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">SuperClass</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 混合其它</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(<span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="title class_">OtherSuperClass</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="comment">// 重新指定constructor</span></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> = <span class="title class_">MyClass</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MyClass</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myMethod</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="ES6-类继承-extends"><a href="#ES6-类继承-extends" class="headerlink" title="ES6 类继承 extends"></a>ES6 类继承 extends</h1><p><code>ES6</code> 的继承和寄生组合继承相似，本质上 <code>ES6</code> 继承是 <code>ES5</code> 继承的一种语法糖</p>
<p><code>extends</code> 关键字主要用于类声明或类表达式中，以创建一个类表示该类是另外某个类的子类  </p>
<p><code>constructor</code> 表示构造函数，一个类中只能有一个构造函数，有多个会报出<code>SyntaxError</code> 错误，若没有显式指定构造方法，则会添加默认的 <code>constructor</code> 方法，例子如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123; </span><br><span class="line">  <span class="comment">// constructor </span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">height, width</span>) &#123; </span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">height</span> = height; <span class="variable language_">this</span>.<span class="property">width</span> = width;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// Getter </span></span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">area</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">calcArea</span>() &#125; </span><br><span class="line">  <span class="comment">// Method </span></span><br><span class="line">  <span class="title function_">calcArea</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">height</span> * <span class="variable language_">this</span>.<span class="property">width</span>; &#125; </span><br><span class="line">&#125;    </span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> rectangle = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(<span class="number">10</span>, <span class="number">20</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(rectangle.<span class="property">area</span>); <span class="comment">// 输出 200 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Rectangle</span> &#123; </span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">length</span>) &#123; </span><br><span class="line">    <span class="variable language_">super</span>(length, length); <span class="comment">// 如果子类中存在构造函数，则需要在使用“this”之前首先调用 super()。 </span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = <span class="string">&#x27;Square&#x27;</span>; </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">area</span>() &#123; <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">height</span> * <span class="variable language_">this</span>.<span class="property">width</span>; &#125; </span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> square = <span class="keyword">new</span> <span class="title class_">Square</span>(<span class="number">10</span>); </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(square.<span class="property">area</span>); <span class="comment">// 输出 100</span></span><br></pre></td></tr></table></figure>

<p><code>extends</code> 继承的核心代码如下，其实现和上述的寄生组合式继承方式类似</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// extends 继承的核心代码如下，其实现和上述的寄生组合式继承方式相似</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">_inherits</span>(<span class="params">subType, superType</span>) &#123; </span><br><span class="line">  <span class="comment">// 创建对象，创建父类原型的一个副本 </span></span><br><span class="line">  <span class="comment">// 增强对象，弥补因重写原型而失去的默认的constructor 属性 </span></span><br><span class="line">  <span class="comment">// 指定对象，将新创建的对象赋值给子类的原型 </span></span><br><span class="line">  subType.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(superType &amp;&amp; superType.<span class="property"><span class="keyword">prototype</span></span>, &#123; </span><br><span class="line">    <span class="attr">constructor</span>: &#123; </span><br><span class="line">      <span class="attr">value</span>: subType, </span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>, </span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>, </span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span> </span><br><span class="line">    &#125; </span><br><span class="line">  &#125;); </span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (superType) &#123; </span><br><span class="line">    <span class="title class_">Object</span>.<span class="property">setPrototypeOf</span> ? </span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">setPrototypeOf</span>(subType, superType) : </span><br><span class="line">    subType.<span class="property">__proto__</span> = superType; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<ul>
<li><p>函数声明和类声明的区别：函数声明会提升，类声明不会。首先需声明类然后访问它，否则像下面的代码会抛出一个 <code>ReferenceError</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Rectangle</span>(); </span><br><span class="line"><span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ES6 <code>Class extends</code> 是 <code>ES5</code> 继承的语法糖</p>
</li>
<li><p><code>ES5</code> 继承和 <code>ES6</code> 继承的区别</p>
<p><code>ES5</code> 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 <code>this</code> 上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Child</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Parent</span>() || <span class="title class_">Parent</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>) || <span class="title class_">Parent</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>)</span><br></pre></td></tr></table></figure>

<p><code>ES6</code> 的继承有所不同</p>
<ul>
<li>在 <code>ES6 class</code> 中，实质上是先创建父类的实例对象 <code>this</code>，然后再用子类的构造函数修改 <code>this</code></li>
<li>子类必须在 <code>constructor</code> 方法中调用 <code>super</code> 方法，否则新建实例时会报错。这是因为子类没有自己的 <code>this</code> 对象，而是继承父类的 <code>this</code> 对象，然后对其进行加工</li>
</ul>
</li>
</ul>
<h1 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h1><h2 id="一道关于原型的题目"><a href="#一道关于原型的题目" class="headerlink" title="一道关于原型的题目"></a>一道关于原型的题目</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Page</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">hosts</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Page</span>.<span class="property">hosts</span> = [<span class="string">&#x27;h1&#x27;</span>];</span><br><span class="line"><span class="title class_">Page</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">hosts</span> = [<span class="string">&#x27;h2&#x27;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Page</span>();</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="title class_">Page</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">hosts</span>);  <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p2.<span class="property">hosts</span>); <span class="comment">// Uncaught TypeError: Cannot read property &#x27;hosts&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ul>
<li><p>上面提过 <code>new</code> 时若 <code>return</code> 了一个对象，则会直接拿这个对象作为 <code>new</code> 的结果。因此 <code>p1</code> 应该是 <code>this.hosts</code> 的结果，而在 <code>new Page()</code> 时 <code>this</code> 是一个以 <code>Page.prototype</code> 为原型的 <code>target</code> 对象，所以这里 <code>this.hosts</code> 可以访问到 <code>Page.prototype.hosts</code> 即 <code>[&#39;h2&#39;]</code>，因此 <code>p1</code> 就是等于 <code>[&#39;h2&#39;]</code>，但 <code>[&#39;h2&#39;]</code> 没有 <code>hosts</code> 属性所以返回 <code>undefined</code></p>
</li>
<li><p><code>console.log(p2.hosts)</code> 会报错是因为 <code>p2</code> 是直接调用 <code>Page</code> 构造函数，这个时候 <code>this</code> 指向全局对象，全局对象并没 <code>hosts</code> 属性，因此返回 <code>undefined</code>，往 <code>undefined</code> 上访问 <code>hosts</code> 当然报错</p>
</li>
</ul>
<h2 id="ES5-中的“类”和-ES6-中的-class-有什么区别？"><a href="#ES5-中的“类”和-ES6-中的-class-有什么区别？" class="headerlink" title="ES5 中的“类”和 ES6 中的 class 有什么区别？"></a>ES5 中的“类”和 ES6 中的 class 有什么区别？</h2><p>在 <code>ES5</code> 中主要是通过<code>构造函数</code>方式和<code>原型</code>方式来定义一个类，在 <code>ES6</code> 中可以通过 <code>class</code> 来定义类</p>
<ul>
<li><p><code>class</code> 类必须 <code>new</code> 调用，不能直接执行</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">like</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`like<span class="subst">$&#123;<span class="variable language_">this</span>.color&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>();</span><br><span class="line"><span class="comment">// Uncaught TypeError: Class constructor Foo cannot be invoked without &#x27;new&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>class</code> 类执行的话会报错，而 <code>ES5</code> 中的类和普通函数并没有本质区别，执行肯定是 <code>OK</code> 的</p>
</li>
<li><p><code>class</code> 类不存在变量提升</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">color</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">like</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`like<span class="subst">$&#123;<span class="variable language_">this</span>.color&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo; <span class="comment">// Foo &#123;color: undefined&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">like</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`like<span class="subst">$&#123;<span class="variable language_">this</span>.color&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught ReferenceError: Foo is not defined</span></span><br></pre></td></tr></table></figure>

<p>上面示例说明 <code>class</code> 方式没有把类的定义提升到顶部</p>
</li>
<li><p><code>class</code> 类无法遍历它实例原型链上的属性和方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Foo</span>(<span class="params">color</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Foo</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">like</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`like<span class="subst">$&#123;<span class="variable language_">this</span>.color&#125;</span>`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> foo) &#123;</span><br><span class="line">  <span class="comment">// 原型上的 like 也被打印出来了</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// color like</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// class </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">color</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">color</span> = color;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">like</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`like<span class="subst">$&#123;<span class="variable language_">this</span>.color&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> <span class="title class_">Foo</span>(<span class="string">&#x27;red&#x27;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> foo) &#123;</span><br><span class="line">  <span class="comment">// 没有打印原型链上的 like</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>new.target</code> 属性 </p>
<p><code>ES6</code> 为 <code>new</code> 命令引入了一个 <code>new.target</code> 属性，它会返回 <code>new</code> 命令作用于的那个构造函数，若不是通过 <code>new</code> 调用或 <code>Reflect.construct()</code> 调用，则 <code>new.target</code> 会返回 <code>undefined</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Person</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;必须使用 new 命令生成实例&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 此时使用非 new 的调用方式则会报错</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">call</span>(obj, <span class="string">&#x27;xx&#x27;</span>); <span class="comment">// Uncaught Error: 必须使用 new 命令生成实例</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>class</code> 类有 <code>static</code> 静态方法</p>
<p><strong><code>static</code> 静态方法只能通过类调用，不会出现在实例上；若 <code>static</code> 静态方法包含 <code>this</code> 关键字，这个 <code>this</code> 指的是类而不是实例</strong></p>
<p><code>static</code> 声明的静态属性和方法均可被子类继承</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Bar</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">baz</span>(); <span class="comment">// 此处的 this 指向类</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello&#x27;</span>); <span class="comment">// 不会出现在实例中</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">baz</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;world&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Bar</span>.<span class="title function_">bar</span>(); <span class="comment">// hello</span></span><br></pre></td></tr></table></figure></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://donnapersonal.github.io/cn">Donna Tang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://donnapersonal.github.io/cn/posts/jsbasic-inherit/">https://donnapersonal.github.io/cn/posts/jsbasic-inherit/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://donnapersonal.github.io/cn" target="_blank">Donna'Log</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/cn/tags/JS/">JS</a></div><div class="post-share"><div class="social-share" data-image="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2rvii9f6z2.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/cn/posts/jsbasic-prototype/" title="JavaScript 基础 - 重新认识构造函数、原型、原型链、继承"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.73ubpkycwk.webp" onerror="onerror=null;src='/cn/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">JavaScript 基础 - 重新认识构造函数、原型、原型链、继承</div></div><div class="info-2"><div class="info-item-1">构造函数什么是构造函数构造函数 就是提供一个生成对象的模板并描述对象基本结构的函数。一个构造函数可以生成多个对象，这些对象都有相同的结构  构造函数 本身就是一个函数，不过为了规范一般将其首字母大写  构造函数 和 普通函数 的区别在于使用 new 生成实例的函数就是构造函数，直接调用的就是普通函数   生成对象实例时必须使用 new 命令来调用构造函数，所以构造函数更合理的理解应该是函数的构造调用 constructor 返回创建实例对象时构造函数的引用，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串 1234567function Person(age) &#123;  this.age = age;&#125;var p = new Person(18);p.constructor === Person; // truep.constructor === Object; // false  那普通函数创建的实例是不是一定没有 constructor 属性呢？不一定 12345678910111213141516// 普通函数function person(ag...</div></div></div></a><a class="pagination-related" href="/cn/posts/0.1+0.2/" title="为什么 0.1 + 0.2 !== 0.3"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.6m494gp9dv.webp" onerror="onerror=null;src='/cn/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">为什么 0.1 + 0.2 !== 0.3</div></div><div class="info-2"><div class="info-item-1">背景在浏览器控制台窗口输入以下两行代码，结果出乎意料 1230.1 + 0.2 &gt; 0.3  // true0.1 + 0.2 = 0.300000000000000040.1 * 0.1 = 0.010000000000000002  前置知识在计算机的世界里，应该是只有二进制数据的，不是 0 就是 1，为了表达生活中最为常见的十进制数据，则就会有个转换过程 十进制转为二进制十进制转换为二进制这个过程整体总结就是：  整数采用整数除 2 取余，直到商为 0 时为止，将余数逆序排列 小数采用小数部分乘以 2，取整，直到得到小数部分 0 或达到所要求的精度为止，将整数顺序排列  二进制转为十进制12345678910111213// 以二进制 10101101.1101 为例  // 针对整数部分 10101101 计算逻辑如下// ← 从右往左1 * 2^0 + 0 * 2^1 + 1 * 2^2 + 1 * 2^3 + 0 * 2^4 + 1 * 2^5 + 0 * 2^6 + 1 * 2^7= 1 + 0 + 4 + 8 + 0 + 32 + 0 + 128= 173/...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/cn/posts/+operator/" title="JS 的 {} + {} 与 {} + [] 的结果是什么？"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.8s3omkauw3.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="info-item-2">JS 的 {} + {} 与 {} + [] 的结果是什么？</div></div><div class="info-2"><div class="info-item-1">前言在 JS 中，+ 符号是很常见的一种，它有以下的使用情况：  数字的加法运算，二元运算 字符串的连接运算，二元运算，优先级最高 正号，一元运算，可延伸为强制转换其他类型的运算元为数字类型  另一个常见的是花括号 &#123;&#125;，它有两个用途也很常见：  对象的字面定义 区块语句  加号运算符 +除了上面说明的常见情况外，在标准中转换的规则还有以下几个，要注意它的顺序：operand + operand = result  使用 ToPrimitive 运算转换左与右运算元为原始数据类型值 (primitive) 在第 1 步转换后，若有运算元出现原始数据类型是&quot;字符串&quot;类型值时，则另一运算元作强制转换为字符串，然后作字符串的连接运算 (concatenation) 其他情况时，所有运算元都会转换为原始数据类型的&quot;数字&quot;类型，然后作数学的相加运算(addition)  ToPrimitive 内部运算因此，加号运算符只能使用于原始数据类型，那么对于对象类型的值要如何转换为原始数据类型？ JavaScript 对象转换到基本类型值...</div></div></div></a><a class="pagination-related" href="/cn/posts/jsbasic-datatype/" title="JavaScript 基础 - 数据类型、运算符、类型转换"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.7i0rgcc8cp.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="info-item-2">JavaScript 基础 - 数据类型、运算符、类型转换</div></div><div class="info-2"><div class="info-item-1">数据类型原始（Primitive）类型原始（Primitive）值一般叫做栈数据（一旦开了个房间、不可能在这个房间里对其进行修改） 在 JS 中，存在着以下几种原始值，分别是：  number（typeof 1 === &quot;number&quot;） string（typeof &#39;&#39; === &quot;string&quot;） boolean（typeof true === &quot;boolean&quot;） null（typeof null === &quot;object&quot;） undefined（typeof undefined === &quot;undefined&quot;） symbol（typeof Symbol() === &quot;symbol&quot;） bigInt（typeof 10n === &quot;bigint&quot;）(没有正式发布但即将被加入标准的原始类型)  原始类型存储的都是值，是没有函数可以调用的，如 undefined.toString() 会报错，一般看到的 &#39;1&#39;....</div></div></div></a><a class="pagination-related" href="/cn/posts/jsbasic-handwriting/" title="JavaScript 基础 - 高频手写"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9ddc96s40g.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-09</div><div class="info-item-2">JavaScript 基础 - 高频手写</div></div><div class="info-2"><div class="info-item-1">模拟 Object.is()Object.is() 在 === 的基础上修复了一些特殊情况下的失误，具体来说就是：  +0 不等于 -0 NaN 等于自身  1234567891011function objectIs(x, y) &#123;  if(x === y) &#123;    // 运行到 1/x === 1/y 时 x 和 y 都为 0    // 但 1/+0 = +Infinity，1/-0 = -Infinity 是不一样的    return x !== 0 || y !== 0 || 1 / x === 1 / y;  &#125; else &#123;    // NaN === NaN 是 false，在这里做个拦截，x !== x 一定是 NaN, y 同理    // 两个都是 NaN 时返回 true    return x !== x &amp;&amp; y !== y;  &#125;&#125;  模拟 new当执行 new Foo(...) 时，会发生以下事情：  一个继承自 Foo.prototype 的新对象被创建 使用指定的参...</div></div></div></a><a class="pagination-related" href="/cn/posts/jsbasic-prototype/" title="JavaScript 基础 - 重新认识构造函数、原型、原型链、继承"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.73ubpkycwk.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-08</div><div class="info-item-2">JavaScript 基础 - 重新认识构造函数、原型、原型链、继承</div></div><div class="info-2"><div class="info-item-1">构造函数什么是构造函数构造函数 就是提供一个生成对象的模板并描述对象基本结构的函数。一个构造函数可以生成多个对象，这些对象都有相同的结构  构造函数 本身就是一个函数，不过为了规范一般将其首字母大写  构造函数 和 普通函数 的区别在于使用 new 生成实例的函数就是构造函数，直接调用的就是普通函数   生成对象实例时必须使用 new 命令来调用构造函数，所以构造函数更合理的理解应该是函数的构造调用 constructor 返回创建实例对象时构造函数的引用，此属性的值是对函数本身的引用，而不是一个包含函数名称的字符串 1234567function Person(age) &#123;  this.age = age;&#125;var p = new Person(18);p.constructor === Person; // truep.constructor === Object; // false  那普通函数创建的实例是不是一定没有 constructor 属性呢？不一定 12345678910111213141516// 普通函数function person(ag...</div></div></div></a><a class="pagination-related" href="/cn/posts/0.1+0.2/" title="为什么 0.1 + 0.2 !&#x3D;&#x3D; 0.3"><img class="cover" src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.6m494gp9dv.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-16</div><div class="info-item-2">为什么 0.1 + 0.2 !&#x3D;&#x3D; 0.3</div></div><div class="info-2"><div class="info-item-1">背景在浏览器控制台窗口输入以下两行代码，结果出乎意料 1230.1 + 0.2 &gt; 0.3  // true0.1 + 0.2 = 0.300000000000000040.1 * 0.1 = 0.010000000000000002  前置知识在计算机的世界里，应该是只有二进制数据的，不是 0 就是 1，为了表达生活中最为常见的十进制数据，则就会有个转换过程 十进制转为二进制十进制转换为二进制这个过程整体总结就是：  整数采用整数除 2 取余，直到商为 0 时为止，将余数逆序排列 小数采用小数部分乘以 2，取整，直到得到小数部分 0 或达到所要求的精度为止，将整数顺序排列  二进制转为十进制12345678910111213// 以二进制 10101101.1101 为例  // 针对整数部分 10101101 计算逻辑如下// ← 从右往左1 * 2^0 + 0 * 2^1 + 1 * 2^2 + 1 * 2^3 + 0 * 2^4 + 1 * 2^5 + 0 * 2^6 + 1 * 2^7= 1 + 0 + 4 + 8 + 0 + 32 + 0 + 128= 173/...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/cn/img/avatar.JPG" onerror="this.onerror=null;this.src='/cn/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Donna Tang</div><div class="author-info-description">Learn more! Think more! Do more!</div><div class="site-data"><a href="/cn/archives/"><div class="headline">文章</div><div class="length-num">6</div></a><a href="/cn/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/cn/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/donnapersonal"><i class="fab fa-github"></i><span>GitHub</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog! <br>Migrating from old blog!</br></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">1.</span> <span class="toc-text">继承</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES5-%E7%BB%A7%E6%89%BF%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">ES5 继承实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF"><span class="toc-number">2.1.</span> <span class="toc-text">原型链继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%80%9F%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF"><span class="toc-number">2.2.</span> <span class="toc-text">借用构造函数继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E7%BB%A7%E6%89%BF"><span class="toc-number">2.3.</span> <span class="toc-text">组合继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.</span> <span class="toc-text">原型式继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">2.5.</span> <span class="toc-text">寄生式继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E7%94%9F%E7%BB%84%E5%90%88%E5%BC%8F%E7%BB%A7%E6%89%BF"><span class="toc-number">2.6.</span> <span class="toc-text">寄生组合式继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B7%E5%85%A5%E6%96%B9%E5%BC%8F%E7%BB%A7%E6%89%BF%E5%A4%9A%E4%B8%AA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.7.</span> <span class="toc-text">混入方式继承多个对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ES6-%E7%B1%BB%E7%BB%A7%E6%89%BF-extends"><span class="toc-number">3.</span> <span class="toc-text">ES6 类继承 extends</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%A9%E5%B1%95"><span class="toc-number">4.</span> <span class="toc-text">扩展</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E9%81%93%E5%85%B3%E4%BA%8E%E5%8E%9F%E5%9E%8B%E7%9A%84%E9%A2%98%E7%9B%AE"><span class="toc-number">4.1.</span> <span class="toc-text">一道关于原型的题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ES5-%E4%B8%AD%E7%9A%84%E2%80%9C%E7%B1%BB%E2%80%9D%E5%92%8C-ES6-%E4%B8%AD%E7%9A%84-class-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.2.</span> <span class="toc-text">ES5 中的“类”和 ES6 中的 class 有什么区别？</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/jsbasic-handwriting/" title="JavaScript 基础 - 高频手写"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.9ddc96s40g.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="JavaScript 基础 - 高频手写"/></a><div class="content"><a class="title" href="/cn/posts/jsbasic-handwriting/" title="JavaScript 基础 - 高频手写">JavaScript 基础 - 高频手写</a><time datetime="2021-07-10T01:10:53.000Z" title="发表于 2021-07-09 21:10:53">2021-07-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/jsbasic-inherit/" title="JavaScript 基础 - 继承"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.2rvii9f6z2.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="JavaScript 基础 - 继承"/></a><div class="content"><a class="title" href="/cn/posts/jsbasic-inherit/" title="JavaScript 基础 - 继承">JavaScript 基础 - 继承</a><time datetime="2021-07-09T01:10:53.000Z" title="发表于 2021-07-08 21:10:53">2021-07-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/jsbasic-prototype/" title="JavaScript 基础 - 重新认识构造函数、原型、原型链、继承"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.73ubpkycwk.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="JavaScript 基础 - 重新认识构造函数、原型、原型链、继承"/></a><div class="content"><a class="title" href="/cn/posts/jsbasic-prototype/" title="JavaScript 基础 - 重新认识构造函数、原型、原型链、继承">JavaScript 基础 - 重新认识构造函数、原型、原型链、继承</a><time datetime="2021-07-09T01:10:53.000Z" title="发表于 2021-07-08 21:10:53">2021-07-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/0.1+0.2/" title="为什么 0.1 + 0.2 !== 0.3"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.6m494gp9dv.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="为什么 0.1 + 0.2 !== 0.3"/></a><div class="content"><a class="title" href="/cn/posts/0.1+0.2/" title="为什么 0.1 + 0.2 !== 0.3">为什么 0.1 + 0.2 !== 0.3</a><time datetime="2021-05-17T01:35:51.000Z" title="发表于 2021-05-16 21:35:51">2021-05-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/cn/posts/jsbasic-datatype/" title="JavaScript 基础 - 数据类型、运算符、类型转换"><img src="https://github.com/donnapersonal/picx-images-hosting/raw/master/image.7i0rgcc8cp.webp" onerror="this.onerror=null;this.src='/cn/img/404.jpg'" alt="JavaScript 基础 - 数据类型、运算符、类型转换"/></a><div class="content"><a class="title" href="/cn/posts/jsbasic-datatype/" title="JavaScript 基础 - 数据类型、运算符、类型转换">JavaScript 基础 - 数据类型、运算符、类型转换</a><time datetime="2021-05-16T19:49:09.000Z" title="发表于 2021-05-16 15:49:09">2021-05-16</time></div></div></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2019 - 2025 By Donna Tang</span></div><div class="footer_custom_text">Hi, welcome to my blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/cn/js/utils.js"></script><script src="/cn/js/main.js"></script><div class="js-pjax"></div><script data-pjax src="/self/btf.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => fn())
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/cn/404') : window.location.href = '/cn/404')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/cn/js/search/local-search.js"></script></div></div></body></html>